#!/usr/bin/perl
####################################################################
# Script to test the LCG services inside the VOBOX
# USAGE: lcg_vobox_services
# Author, bugs, questions: patricia.mendez@cern.ch
###################################################################

use strict;
use warnings;

use Net::Domain qw(hostname hostfqdn hostdomain);
use Net::LDAP;
use Net::LDAP::Entry;

######## REDEFINITION OF THE ENV ##################

delete $ENV{'GLOBUS_LOCATION'};
delete $ENV{'X509_CERT_DIR'};
delete $ENV{'MYPROXY_LOCATION'};

$ENV{'GLOBUS_LOCATION'}="/opt/globus";
$ENV{'X509_CERT_DIR'}="/etc/grid-security/certificates";
$ENV{'LD_LIBRARY_PATH'}="/opt/lcg/lib64:/opt/globus/lib:/opt/glite/lib64:/opt/glite/lib:$ENV{'LD_LIBRARY_PATH'}";
$ENV{'PATH'}="$ENV{'HOME'}/bin:/usr/kerberos/bin:/opt/d-cache/srm/bin:/opt/d-cache/dcap/bin:/opt/edg/bin:/opt/glite/bin:/opt/globus/bin:/opt/lcg/bin:/usr/bin:/bin:/usr/sbin:/sbin";
### helper functions ################################
system("env |sort > /tmp/env");
sub dumpStatus {
    my $service = shift;
    my $status = shift;
    my $message = shift;
    my %others = @_;
    $others{"Message"} = $message if($message);
    my $extra = "";
    while(my ($key, $value) = each(%others)){
        $extra .= "\t$key\t$value";
    }
    print "$service\tStatus\t$status".$extra."\n";
}

# take only the last 5 lines of the given string and concatenate them;
# remove any tabs
sub filter_out {
    my $text = shift;
    
    $text =~ s/\t/ /g;
    my @lines=split(/\n/, $text);
    @lines = @lines[@lines-5 .. @lines-1] if(@lines > 5);
    return join(" ", @lines);
}

sub parse_proxy_timeleft {
    my $proxy_file = shift;
    my $command = shift;
    my $proxy_type = shift;

    my $proxy_out = `$command 2>&1`;
    return (1, "Failed to execute '$command': ".filter_out($proxy_out), 0) if ($?);
    
    my $leftt = $1 if $proxy_out =~ /timeleft\s*:\s*([0-9:]*)/g;
    my $timeleft = 0;
    my $err = 0;
    my $msg = undef;
    if($leftt){
            my @leftl = reverse(split(/:/, $leftt));
            $timeleft = ($leftl[0] || 0) + 60 * ($leftl[1] || 0) + 3600 * ($leftl[2] || 0);
    }else{
            $msg = ($proxy_file ?
                    (-r $proxy_file ?
                            "$proxy_type doesn't point to a readable file."
                            :
                            "Failed checking the proxy for $proxy_type.")
                    :
                    "Undefined proxy file for $proxy_type.");
            $err = 1;
    }
    return ($err, $msg, $timeleft);
} 

my $currentpath = $ENV{PWD};
#####################################################
# 1st TEST:
# Checking if the proxy renewal service is running
######################################################
sub test1 {
    my $service = "Proxy Renewal";
    my $rez = `/etc/init.d/alice-box-proxyrenewal status 2>&1` || "Failed to execute /etc/init.d/alice-box-proxyrenewal status";
    
    if($rez =~ /Service\s+not\s+running/){
	dumpStatus($service, 1, "Proxy renewal service not running");
    }elsif($rez =~ /Service\s+running\s+in\s+pid/){
	dumpStatus($service, 0);
    }else{
	$rez =~ s/\n/ /g;
	dumpStatus($service, 2, $rez);
    }
}

#####################################################
# 2nd TEST:
# Checking the proxy registration
#####################################################
sub test2 {
    my $service = "User Proxy Registration";
    my $proxy_registration=`vobox-proxy --vo alice --force register 2>&1` || "Failed to execute vobox-proxy --vo alice --force register";
    
    if ($proxy_registration=~ /successfull/ || $proxy_registration=~ /OK/){
	dumpStatus($service, 0);
    }else{
	$proxy_registration =~ s/\n/ /g;
	dumpStatus($service, 1, $proxy_registration);
    }
}

######################################################
# 3rd TEST:
# Checking gsiscp service
######################################################
sub test3 {
    my $service = "gsiscp";
    my $host = hostfqdn();
    my $gsissh_service=`gsiscp -P 1975 /etc/group $host:/tmp/$host$$ > /dev/null 2> /dev/null`;
    if($?){
	dumpStatus($service, 1, "Failed to execute gsiscp. Probably the service is down");
    }else{
	system("rm /tmp/$host$$");
	dumpStatus($service, 0);
    }
}

######################################################################
# 4th TEST:
# is the machine properly registered inside the myproxy server?
######################################################################
sub test4 {
    my $service = "Proxy Server";
    my $proxy_server = $ENV{MYPROXY_SERVER};
    if (!$proxy_server){
	dumpStatus($service, 1, "The myproxy server is not defined");
    }else{
	my $query = "prod-bdii.cern.ch:2170";
	my $host = hostfqdn();
	my $base="o=grid";
	my (%test_hash, @elemento1, @elemento2);
	my $querySer = "Query to the proxy server";
	my $connSer = "Connection to the proxy server";
	my $regSer = "Registration of the VOBOX in the myproxy server";
	if (my $ldap = Net::LDAP->new($query)){
	    dumpStatus($querySer, 0);
	    if ($ldap->bind){
		dumpStatus($connSer, 0);
		my $mesg = $ldap->search( base   => "$base",
					  filter => "objectClass=GlueTop"
					  );
		
		my $total = $mesg->count;
		
		my @values=$mesg->entry(0)->get_value("GlueServiceAccessControlRule");
		my $tmp_vals = @values;
		
		$ldap->unbind;
		
		for ( my $t = 0 ; $t < $tmp_vals ; $t++ ) {
		    $elemento1[$t] = $values[$t];
		    $elemento2[$t] = $t;
		    
		    $test_hash{$elemento1[$t]} = $elemento2[$t];
		}
				
		foreach (sort keys %test_hash){
		    if (/$host/){
			dumpStatus($regSer, 0);
		    }
		    else {
			dumpStatus($regSer, 1, "This node is not registered in the myproxy server");
		    }
		}
	    }else{
		dumpStatus($connSer, 1, "BDII server [ $query ] does not respond to the connection");
	    }
	}else{
	    dumpStatus($querySer, 1, "BDII server [ $query ] does not respond");
	}
	
	# check the timeleft of the MyProxy
	my $command = "env X509_USER_CERT=$ENV{X509_USER_PROXY} X509_USER_KEY=$ENV{X509_USER_PROXY} myproxy-info -d 2>/dev/null";
	my ($err, $msg, $timeleft) = parse_proxy_timeleft($ENV{X509_USER_PROXY}, $command, "X509_USER_CERT/KEY/PROXY for MyProxy");
	dumpStatus($service, $err, $msg, 'timeleft' => $timeleft);
    }
}

##################################################
# 5th TEST:
# is the machine running its proxy?
##################################################
sub test5 {
    my $service = "Proxy of the machine";
    if(! -d "/opt/vobox/alice"){
	dumpStatus($service, 1, "Directory /opt/vobox/alice does not exist");
    }else{
	my $proxy_file = "/opt/vobox/alice/renewal-proxy.pem";
	my $command = "grid-proxy-info -f $proxy_file 2>/dev/null";
	my ($err, $msg, $timeleft) = parse_proxy_timeleft($proxy_file, $command, "renewal-proxy.pem");
	dumpStatus($service, $err, $msg, 'timeleft' => $timeleft);
    }
}

##################################################
# 6th TEST:
# what is the duration of delegation proxy we can get
##################################################
sub test6 {
   my $service = "Delegated proxy";
   
   my $renewalProxy = "/opt/vobox/alice/renewal-proxy.pem";
   my $currentProxy = $ENV{X509_USER_PROXY};
   my $duration = 259_200;	# 3 days
   my $delegatedFile = "/tmp/tmpfile.$$";
 
   if(-r $renewalProxy){
      if(-r $currentProxy){
	 my $info = "";
	 $ENV{X509_USER_PROXY} = $renewalProxy;
	 my @command;
	 if(-x "$ENV{LCG_LOCATION}/bin/lcg-proxy-renew"){
	   $info = "with VOMS extensions";
	   @command = ( "$ENV{LCG_LOCATION}/bin/lcg-proxy-renew",
		   "-a",    $currentProxy,
		   "-d",
		   "-o",    $delegatedFile,
		   "-voms", "alice:/alice/Role=lcgadmin",
		   "-cert", $renewalProxy,
		   "-key",  $renewalProxy,
		   "2>/dev/null");
         }else{
	   @command = ( 'myproxy-get-delegation',
                   "-a", "$currentProxy",
                   "-d",
                   "-t", int($duration/3600), #in hours
                   "-o", $delegatedFile);
	 }
	 my $out=`@command`;
	 if($?){
	    dumpStatus($service, 1, "Unable to get delegation $info ".filter_out($out), 'timeleft' => 0);
	 }else{
	    $ENV{X509_USER_PROXY} = $delegatedFile;
	    @command = ('vobox-proxy',
		  "--vo", "alice",
		  "query-proxy-timeleft");
	    $out = `@command`;
	    if($?){
	       dumpStatus($service, 1, "Failed to check proxy timeleft $info ".filter_out($out), 'timeleft' => 0);
	    }else{
	       if($out =~ /\s*(\d+)\s*/){
		  dumpStatus($service, 0, $info, 'timeleft' => $1);
	       }else{
		  dumpStatus($service, 1, "Failed to parse timeleft $info ".filter_out($out), 'timeleft' => 0);
	       }
	    }
	 }
	 unlink($delegatedFile);
	 $ENV{X509_USER_PROXY} = $currentProxy;
      }else{
	 dumpStatus($service, 1, 'Cannot read USER_PROXY', 'timeleft' => 0);
      }
   }else{
      dumpStatus($service, 1, 'Cannot read renewal_proxy.pem', 'timeleft' => 0);
   }
}



################################################################
# 7th TEST:
# Check if the access to the software area is properly defined for alicesgm persons
################################################################
sub test7 {
    my $service = "Software area";
    if (! $ENV{VO_ALICE_SW_DIR}){
	dumpStatus($service, 1, "VO_ALICE_SW_DIR is not defined");
    }else{
	chdir "$ENV{VO_ALICE_SW_DIR}> /dev/null 2> /dev/null";
	if($?){
	    dumpStatus($service, 1, "permission denied");
	}else{
	    dumpStatus($service, 0);
	}
    }
}

################################################################
# 8th TEST:
# is the catalog properly defined in the environment?
################################################################
sub test8 {
        
    my $service = "Local catalog";
    if(! $ENV{LFC_HOST}){
	dumpStatus($service, 1, "LFC_HOST is not defined inside the VOBOX");
    }else{
	`lfc-ls /grid/alice > /dev/null 2> /dev/null`;
	if($?){
	    dumpStatus($service, 2, "Cannot access catalog");
	}else{
	    dumpStatus($service, 0);
	}
    }
    
    #Creating a jdl
    system("rm -f test*.jdl");
    open VOBOX, ">>test$$.jdl" or die "Cannot open the jdl file\n";
    print VOBOX "Executable = \"/bin/hostname\";\n";
    print VOBOX "StdOutput = \"std.out\";\n";
    print VOBOX "Stderror = \"std.out\";\n";
    print VOBOX "OutputSandbox = {\"std.out\"};\n";
    close VOBOX;
    
    
    # Getting the information for the RB
    my $rb_placement = "";
    if(open (FILE, "$ENV{HOME}/.alien/alice.conf")){
        while (<FILE>){
	    chomp;
	    my $inputs = $_;
	    if ($inputs =~ /^CE_EDG_WL_UI_CONF/){
	        my @the_rb = split /\s+/, $inputs;
	        $rb_placement = "$the_rb[1]";
	    }
        }
        close FILE;
    }
    
    #Checking the RB
    my $submission;
    $service = "Job submission";
    if($rb_placement){
	$submission = `edg-job-list-match --config-vo $rb_placement test$$.jdl 2>/dev/null`;
    }else{
	$submission = `edg-job-list-match --vo alice test$$.jdl 2>/dev/null`;
    }
    if($?){
	dumpStatus($service, 1, "Failed to execute edg-job-list-match --vo alice test$$.jdl");
    }else{
	if ($submission=~ /ERROR/){
	    dumpStatus($service, 1, "problems with the RB");
	}else{
	    dumpStatus($service, 0);
	}
    }
    
    # removing the jdl
    system "rm -f test$$.jdl";
}

#############################################
# 9th TEST:
# Checking the access to the local BDII
# and the SE appears there
#############################################
sub test9 {
    my $site_name;
    
    if (!$ENV{SITE_NAME} && !$ENV{GLITE_SD_SITE}){
	dumpStatus("Name of the site", 2, "The name of the site is not defined");
    }else{
	$site_name = $ENV{SITE_NAME} || $ENV{GLITE_SD_SITE};
	dumpStatus("Name of the site", 0, "Site Name: $site_name");
    }
    my $base="o=grid";
    
#	 First see the name of the CE through the configuration file of alice
    if(! -r "$ENV{HOME}/.alien/alice.conf"){
	dumpStatus("Alien config file", 1, "Cannot read $ENV{HOME}/.alien/alice.conf");
    }else{
	dumpStatus("Alien config file", 0);
	open (FILE, "$ENV{HOME}/.alien/alice.conf");
	my $ce_name;
	while (<FILE>){
	    chomp;
	    my $inputs = $_;
	    if ($inputs =~ /^CE_LCGCE/){
		my @the_queue = split /\s+/, $inputs;
		$ce_name = "$the_queue[1]";
	    }
	}
	if (!$ce_name){
	    dumpStatus("LCG Computing Element", 1, "The CE is not defined");
	}else{
	    dumpStatus("LCG Computing Element", 0);
	    
	    my @the_ce = split /:/, $ce_name;
	    my $local_bdii = "$the_ce[0]".":"."2170";
	    my $ldap;
	    my $locBdiiSer = "Local BDII";
	    my $connLocBdii = "Connection to the Local BDII";
	    if($ldap = Net::LDAP->new($local_bdii)){
		dumpStatus($locBdiiSer, 0);
		if ($ldap->bind) {
		    dumpStatus($connLocBdii, 0);
		    my $mesg = $ldap->search( base   => "$base",
					      filter => "(&(objectClass=GlueCESEBindGroup)(GlueCESEBindGroupCEUniqueID=$ce_name))"
					      );
		    my $total = $mesg->count;
		    my @values=$mesg->entry(0)->get_value("GlueCESEBindGroupSEUniqueID");
		    #$tmp_vals = @values;
		    $ldap->unbind;
		    my $sePub = "Publication of the SE";
		    if (!@values){
			dumpStatus($sePub, 1, "The SE is not defined");
		    }else{
			dumpStatus($sePub, 0);
		    }
		}else{
		    dumpStatus($connLocBdii, 1, "Not possible to establish a connection with the local BDII");
		}
	    }else{
		dumpStatus($locBdiiSer, 1, "Local BDII not answering");
	    }
	}
	close FILE;
    }
}

#############################################
# 10th TEST:
# Checking if the Site appears in
# the LDAP AliEn servier
# 10th TEST:
# Are you using the LFC?
#############################################
sub test10 {
	my $site_name2;
    
	if(open (FILE, "$ENV{HOME}/.alien/alice.conf")){
	    while (<FILE>){
	        chomp;
	        my $inputs = $_;
	        if (($inputs =~ /^\\<CE/) || ($inputs =~ /^\<CE/)){
		    my @the_queue = split /\s+/, $inputs;
		    my $site_name = "$the_queue[1]";
		    @the_queue = split />/, $site_name;
		    $site_name2 = "$the_queue[0]";
	        }
	    }
	    close FILE;
	}
	
	my $service = "Site included in LDAP";
	if(! $site_name2){
	    dumpStatus($service, 1, "Site name cannot be taken from CE entry in ~/.alien/.alice.conf");
	}else{
	    my $ldap_search = `ldapsearch -h aliendb06a.cern.ch -p 8389 -x -LLL -b \"ou=SE,ou=Services,ou=$site_name2,ou=Sites,o=alice,dc=cern,dc=ch\" name 2>/dev/null`;
	    if($?){
		dumpStatus($service, 1, "Failed to run ldapsearch -h aliendb06a.cern.ch -p 8389 -x -b \"ou=SE,ou=Services,ou=$site_name2,ou=Sites,o=alice,dc=cern,dc=ch\" name");
	    }else{
		if ($ldap_search =~ /name/){
		    dumpStatus($service, 0);
		}else{
		    dumpStatus($service, 1, "The site $site_name2 is not included in the LDAP server");
		}
	    }
	}
	
	$service = "LFC defined in LDAP";
	if(! $site_name2){
	    dumpStatus($service, 1, "Site name cannot be taken from CE entry in ~/.alien/.alice.conf");
	}else{
	    my $lfc_use = `ldapsearch -h aliendb06a.cern.ch -p 8389 -x -LLL -b \"ou=SE,ou=Services,ou=$site_name2,ou=Sites,o=alice,dc=cern,dc=ch\" lvmdatabase 2>/dev/null`;
	    if($?){
		dumpStatus($service, 1, "Failed to run ldapsearch -h aliendb06a.cern.ch -p 8389 -x -LLL -b \"ou=SE,ou=Services,ou=$site_name2,ou=Sites,o=alice,dc=cern,dc=ch\" lvmdatabase");
		if($lfc_use =~ /lvmdatabase/){
		    dumpStatus($service, 0);
		}else{
		    dumpStatus($service, 2, "The LFC is not used for site $site_name2");
		}
	    }
	}
}

##################################################
# Test 11:
# Check the timeleft for the FTS proxy
##################################################
sub test11 {
    my $service = "FTS Proxy";
    my ($err, $msg, $timeleft);
    if($ENV{ALIEN_LOGDIR}){
        if(-r "$ENV{ALIEN_LOGDIR}/FTD.env"){
            my $command = "source $ENV{ALIEN_LOGDIR}/FTD.env 2>/dev/null ; myproxy-info -d -s myproxy-fts.cern.ch";
            ($err, $msg, $timeleft) = parse_proxy_timeleft($ENV{X509_USER_PROXY}, $command, "myproxy-fts.cern.ch");
        }else{
            ($err, $msg, $timeleft) = (2, "FTD.env not found in ALIEN_LOGDIR.", 0);
        }
    }else{
        ($err, $msg, $timeleft) = (1, "Env. var. ALIEN_LOGDIR is not defined!", 0);
    }
    dumpStatus($service, $err, $msg, 'timeleft' => $timeleft);
}

##################################################
# Test 12: 
# Test the FTS services inside the VOBOX
##################################################
sub test12 {
	my $service = "FTS local prerequisites";
	require AliEn::UI::Catalogue::LCM;
	my $cat=AliEn::UI::Catalogue::LCM->new({silent=>1}) or
		dumpStatus($service, 1, "Error initializing AliEn Catalogue instance") and
		return;
	# get the sites that support FTD
	my @sitesWithFTD = ();
	if(open(LDAPSEARCH, "$ENV{ALIEN_ROOT}/bin/ldapsearch -h aliendb06a.cern.ch -p 8389 -x -LLL -b 'ou=FTD,ou=Services,ou=LCG,ou=sites,o=alice,dc=cern,dc=ch' name 2>/dev/null | grep name: | awk '{print \$2}' |")){
		while(my $FTDsite=<LDAPSEARCH>){
			chomp($FTDsite);
			push(@sitesWithFTD, $FTDsite);
		}
		close(LDAPSEARCH);
	}
	if(! @sitesWithFTD){
		dumpStatus($service, 1, "Cannot find any FTDs in LDAP!");
		return;
	}
	
	# get my site's FTD name
	my $myFTDname='';
	my $myFQDN = $ENV{ALIEN_HOSTNAME} || hostfqdn();
	if(open(LDAPSEARCH, "$ENV{ALIEN_ROOT}/bin/ldapsearch -h aliendb06a.cern.ch -p 8389 -x -LLL -b 'host=$myFQDN,ou=Config,ou=LCG,ou=sites,o=alice,dc=cern,dc=ch' ftd 2>/dev/null | grep ftd: | awk '{print \$2}' |")){
		$myFTDname = <LDAPSEARCH>;
		chomp($myFTDname) if($myFTDname);
		close(LDAPSEARCH);
	}
	if(! $myFTDname){
		dumpStatus($service, 2, "FTD is not supported for this site!");
		return;
	}
	
	# get the locations (SEs) where this file is mirrored
	my @file_locations = $cat->execute("whereis", "-l", "FTS-test-$myFTDname");
	if(! grep /::$myFTDname$/, @file_locations){
		system("echo 'File to test FTS transfers from $myFTDname\n' > /tmp/FTS-test-$myFTDname");
		$cat->execute("add", "FTS-test-$myFTDname", "/tmp/FTS-test-$myFTDname") or
			dumpStatus($service, 1, "Cannot register my test file (FTS-test-$myFTDname) in AliEn central catalogue") and
			return;
	}
	
	# if we got this far it means that local prerequisites are ok
	dumpStatus($service, 0);

	# try doing some transfers
	for my $otherSite (@sitesWithFTD){
		next if $otherSite == $myFTDname;
		$service = "Last FTS from $otherSite";
		@file_locations = $cat->execute("whereis", "-l", "FTS-test-$otherSite");
		if(grep /::$myFTDname$/, @file_locations){
			if(! $cat->execute("deleteMirror", "FTS-test-$otherSite", "Alice::LCG::$myFTDname")){
				dumpStatus($service, 1, "Failed to delete the file mirrored to this site.");
			}else{
				dumpStatus($service, 0);
			}
		}else{
			dumpStatus($service, 1, "Mirrored file was not found on this site.");
		}
		$service = "Next FTS from $otherSite";
		my ($status, $transferId) = $cat->execute("mirror", "-t", "FTS-test-$otherSite", "Alice::LCG::$myFTDname");
		if (! $status){
			dumpStatus($service, 1, "Error issuing mirror command.");
			next;
		}
		if (! $transferId){
			dumpStatus($service, 1, "Got an invalid transferID from the mirror command.");
			next;
		}
		my $site_status = $cat->execute("listTransfer", "-id", $transferId);
		if(! $site_status){
			dumpStatus($service, 1, "Failed checking transfer status with listTransfer.");
			next;
		}
		dumpStatus($service, 0);#, ${$site_status}[0]->{status});
	}
}

##################################################
# Test 13: 
# Get the last known good RB
##################################################
sub test13 {
	my $service = "Last good RB";

	if($ENV{ALIEN_HOME}){
		if(open(FILE, "$ENV{ALIEN_HOME}/.lastGoodRB")){
			my $line = <FILE>;
			chomp $line;
			close(FILE);
			if($line){
				dumpStatus($service, 0, $line);
			}else{
				dumpStatus($service, 2, "File $ENV{ALIEN_HOME}/.lastGoodRB is empty!");
			}
		}else{
			dumpStatus($service, 1, "Failed to open $ENV{ALIEN_HOME}/.lastGoodRB");
		}
	}else{
		dumpStatus($service, 1, "Env. var. ALIEN_HOME is not defined!");
	}
}

##################################################
# Test 14: 
# Get the last known good RB
##################################################

sub test14 {

    my $service = "DN of the host certificate";
    my $node_dn=`/usr/bin/openssl x509 -subject -in /etc/grid-security/hostcert.pem 2>&1` || "Failed to get the DN of the node";

    if ($node_dn=~ /subject=\s+(\S+)/){
        my $dn= $1;
        dumpStatus($service, 0,$dn);
    }else{
        dumpStatus($service, 1, "The DN of the node cannot be read");
    }

}



for(my $i = 1; $i < 15; $i++){
#	print "Doing test $i...\n";
    eval "test$i()";
}

dumpStatus("SCRIPTRESULT", 0);

