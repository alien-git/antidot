--- work/glite-security-voms-admin-client-1.0.7/perl/gLite/HTTPS.pm	Fri Nov 19 19:01:57 2004
+++ work/glite-security-voms-admin-client-1.0.7/perl/gLite/HTTPS.pm.new	Mon Sep 12 17:11:47 2005
@@ -4,16 +4,14 @@
 
 use strict;
 use FileHandle;
-use Crypt::SSLeay; # to make sure it exists
 
-our %config;
-import gLite::Config;
+our $VERSION = 1.1;
 
 =pod
 
 =head1 NAME
 
-gLite::HTTPS
+EDG::HTTPS
 
 =head1 SYNOPSIS
 
@@ -23,7 +21,7 @@
 
 The main function of this package is B<setEnv()>, which sets the environmental
 variables for the Crypt::SSLeay package, so it will able to authenticate to
-a remote service, e.g. through HTTPS.
+a remote service, e.g. through HTTPS. 
 
 If the effective userid is 0 (root), then the host key and certificate is 
 configured.
@@ -37,6 +35,10 @@
 The split proxy will be cleaned up, when the program finishes. The cleanup
 routine can also be called directly by B<cleanSplitProxy()>.
 
+This module also tries to configure the L<IO::Socket::SSL> module
+properly, if it is used. If this module is not loaded, then it
+fails without any problem.
+
 =head1 OPTIONS
 
 The behaviour can be altered through environmental variables:
@@ -73,9 +75,9 @@
 
 =head1 AUTHORS
 
-Ákos Frohner <Akos.Frohner@cern.ch>, Károly Lorentey <Lorentey.Karoly@elte.hu>
+Akos Frohner <Akos.Frohner@cern.ch>, Karoly Lorentey <Lorentey.Karoly@elte.hu>
 
-Copyright (c) 2003 CERN, ELTE, on behalf of the EU DataGrid project.
+Copyright (c) 2003-2004 CERN, ELTE on behalf of the EU DataGrid and EGEE projects.
 For license conditions see LICENSE file or
 L<http://www.edg.org/license.html>.
 
@@ -86,11 +88,14 @@
 ###
 
 my $proxy; # location of the proxy certificate
+my $debug = 0;
 
 sub setEnv {
+    require Crypt::SSLeay; # to make sure it exists
+
 	# euid is not 0: this is a user with user cert or proxy
 	if($>) {
-		$proxy = $config{X509_USER_PROXY};
+		$proxy = $ENV{X509_USER_PROXY} || "/tmp/x509up_u" . $>;
 
 		eval { splitProxy(); };
 
@@ -98,16 +103,34 @@
 			warn "Couldn't find the proxy file at $proxy\n$@";
 		
 			# fallback solution: the real user certificate
-			$ENV{HTTPS_CERT_FILE} = $config{X509_USER_CERT};
-			$ENV{HTTPS_KEY_FILE}  = $config{X509_USER_KEY};
+			$ENV{HTTPS_CERT_FILE} = $ENV{X509_USER_CERT} ||
+				$ENV{HOME}.'/.globus/usercert.pem';
+			$ENV{HTTPS_KEY_FILE}  = $ENV{X509_USER_KEY} ||
+				$ENV{HOME}.'/.globus/userkey.pem';
 		}
 	}
 	# euid is 0: this is a daemon, so we use the hostcert/key
 	else {
-	    $ENV{HTTPS_CERT_FILE} = $config{GLITE_HOST_CERT};
-	    $ENV{HTTPS_KEY_FILE}  = $config{GLITE_HOST_KEY};
+		$ENV{HTTPS_CERT_FILE} = $ENV{X509_USER_CERT} ||
+		  '/etc/grid-security/hostcert.pem';
+		$ENV{HTTPS_KEY_FILE}  = $ENV{X509_USER_KEY} ||
+		  '/etc/grid-security/hostkey.pem';
 	}
 
+    die "Certificate does not exists: $ENV{HTTPS_CERT_FILE}\n"
+        unless -f $ENV{HTTPS_CERT_FILE};
+    die "Private key does not exists: $ENV{HTTPS_KEY_FILE}\n"
+        unless -f $ENV{HTTPS_KEY_FILE};
+
+    # at this point we have certificate and key, so we can 
+    # do the compatibility step for IO::Socket::SSL
+    if ( exists($INC{'IO/Socket/SSL.pm'}) ) {
+        #warn "Configuring IO::Socket::SSL with certificates\n";
+        $IO::Socket::SSL::GLOBAL_CONTEXT_ARGS->{SSL_cert_file}=$ENV{HTTPS_CERT_FILE};
+        $IO::Socket::SSL::GLOBAL_CONTEXT_ARGS->{SSL_key_file}=$ENV{HTTPS_KEY_FILE};
+        $IO::Socket::SSL::GLOBAL_CONTEXT_ARGS->{SSL_use_cert}=1;
+    }
+    
 	$ENV{HTTPS_VERSION} = 3;
 	$ENV{HTTPS_CA_DIR} = $ENV{X509_CERTDIR} || 
 		'/etc/grid-security/certificates';
@@ -221,5 +244,4 @@
 	
 1;
 
-# Please do not change this line. 
-# arch-tag: 7968addb-a6b5-4727-950e-e3318fa6ce52
+
