diff -Naur work/cyrus-sasl-2.1.21/config.h.in work/cyrus-sasl-2.1.21b/config.h.in
--- work/cyrus-sasl-2.1.21/config.h.in	2005-05-15 08:01:50.000000000 +0200
+++ work/cyrus-sasl-2.1.21b/config.h.in	2006-07-09 23:46:43.000000000 +0200
@@ -356,6 +356,15 @@
 /* The size of a `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
+/* Link ALIENGSSAPI Staticly */
+#undef STATIC_ALIENGSSAPI
+
+/* Link ALIENSSH Staticly */
+#undef STATIC_ALIENSSH
+
+/* Link ALIENTOKEN Staticly */
+#undef STATIC_ALIENTOKEN
+
 /* Link ANONYMOUS Staticly */
 #undef STATIC_ANONYMOUS
 
@@ -428,9 +437,11 @@
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const
 
-/* Define as `__inline' if that's what the C compiler calls it, or to nothing
-   if it is not supported. */
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
 #undef inline
+#endif
 
 /* Define to `int' if <sys/types.h> does not define. */
 #undef mode_t
diff -Naur work/cyrus-sasl-2.1.21/configure.in work/cyrus-sasl-2.1.21b/configure.in
--- work/cyrus-sasl-2.1.21/configure.in	2005-05-07 06:54:18.000000000 +0200
+++ work/cyrus-sasl-2.1.21b/configure.in	2006-07-09 23:10:11.000000000 +0200
@@ -351,6 +351,92 @@
   AC_MSG_RESULT(disabled)
 fi
 
+dnl ************************************************************
+dnl  Globus (www.globus.org) dir. Needed by AliEn-GSSAPI
+AC_ARG_WITH(globus, [  --with-globus=PATH use Globus from PATH [[no]] ],
+	with_globus=$withval,
+	with_globus=no)
+if test "$with_pam" != no; then
+  if test -d $with_globus; then
+    CPPFLAGS="$CPPFLAGS -I${with_globus}/include/gcc32"
+    LDFLAGS="$LDFLAGS -L${with_globus}/lib"
+  fi
+fi
+
+
+dnl AliEn SSH
+AC_ARG_ENABLE(alienssh, [  --enable-alienssh enable ALiEn SSH authentication [[yes]] ],
+  alienssh=$enableval,
+  alienssh=yes)
+
+AC_MSG_CHECKING(AliEn-SSH)
+if test "$alienssh" != no; then
+  AC_MSG_RESULT(enabled)
+  
+  ALIENSSH_LIBS="-lcrypto $LIB_RSAREF"
+  AC_SUBST(ALIENSSH_LIBS)  
+  
+  SASL_MECHS="$SASL_MECHS libalienssh.la"
+  if test "$enable_static" = yes; then
+    SASL_STATIC_OBJS="$SASL_STATIC_OBJS alienssh.o"
+    SASL_STATIC_SRCS="$SASL_STATIC_SRCS ../plugins/alienssh.c"
+    AC_DEFINE(STATIC_ALIENSSH, [], [Link ALIENSSH Staticly])
+  fi
+  
+if test "$with_openssl" = no; then
+  AC_WARN([OpenSSL not found -- AliEn-SSH will be disabled])
+  alienssh=no
+fi
+  
+else
+  AC_MSG_RESULT(disabled)
+fi
+
+
+dnl AliEn Token
+AC_ARG_ENABLE(alientoken, [  --enable-alientoken enable ALiEn Token authentication [[yes]] ],
+  alientoken=$enableval,
+  alientoken=yes)
+
+AC_MSG_CHECKING(AliEn-Token)
+if test "$alientoken" != no; then
+  AC_MSG_RESULT(enabled)
+  
+  SASL_MECHS="$SASL_MECHS libalientoken.la"
+  if test "$enable_static" = yes; then
+    SASL_STATIC_OBJS="$SASL_STATIC_OBJS alientoken.o"
+    SASL_STATIC_SRCS="$SASL_STATIC_SRCS ../plugins/alientoken.c"
+    AC_DEFINE(STATIC_ALIENTOKEN, [], [Link ALIENTOKEN Staticly])
+  fi
+  
+else
+  AC_MSG_RESULT(disabled)
+fi
+
+dnl AliEn GSSAPI
+AC_ARG_ENABLE(aliengssapi, [  --enable-aliengssapi enable ALiEn GSSAPI authentication [[no]] ],
+  aliengassapi=$enableval,
+  aliengssapi=no)
+
+AC_MSG_CHECKING(AliEn-GSSAPI)
+if test "$aliengssapi" != no; then
+  AC_MSG_RESULT(enabled)
+  
+  ALIENGSSAPI_LIBS="-lglobus_gssapi_gsi_gcc32 $LIB_RSAREF"
+  AC_SUBST(ALIENGSSAPI_LIBS)  
+  
+  SASL_MECHS="$SASL_MECHS libaliengssapi.la"
+  if test "$enable_static" = yes; then
+    SASL_STATIC_OBJS="$SASL_STATIC_OBJS aliengssapi.o"
+    SASL_STATIC_SRCS="$SASL_STATIC_SRCS ../plugins/aliengssapi.c"
+    AC_DEFINE(STATIC_ALIENGSSAPI, [], [Link ALIENGSSAPI Staticly])
+  fi
+  
+else
+  AC_MSG_RESULT(disabled)
+fi
+
+
 dnl CRAM-MD5
 AC_ARG_ENABLE(cram, [  --enable-cram           enable CRAM-MD5 authentication [[yes]] ],
   cram=$enableval,
diff -Naur work/cyrus-sasl-2.1.21/Makefile.in work/cyrus-sasl-2.1.21b/Makefile.in
--- work/cyrus-sasl-2.1.21/Makefile.in	2005-05-15 07:58:33.000000000 +0200
+++ work/cyrus-sasl-2.1.21b/Makefile.in	2006-07-09 23:46:45.000000000 +0200
@@ -37,6 +37,8 @@
 POST_UNINSTALL = :
 host_triplet = @host@
 ACLOCAL = @ACLOCAL@
+ALIENGSSAPI_LIBS = @ALIENGSSAPI_LIBS@
+ALIENSSH_LIBS = @ALIENSSH_LIBS@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -186,6 +188,7 @@
 target_os = @target_os@
 target_vendor = @target_vendor@
 AUTOMAKE_OPTIONS = 1.7
+@SASLAUTHD_FALSE@SAD = 
 
 # Top-level Makefile.am for SASL
 # Rob Earhart
@@ -231,13 +234,12 @@
 #
 ################################################################
 @SASLAUTHD_TRUE@SAD = saslauthd
-@SASLAUTHD_FALSE@SAD = 
-@PWCHECK_FALSE@PWC = 
 @PWCHECK_TRUE@PWC = pwcheck
+@PWCHECK_FALSE@PWC = 
 @SAMPLE_FALSE@SAM = 
 @SAMPLE_TRUE@SAM = sample
-@JAVA_TRUE@JAV = java
 @JAVA_FALSE@JAV = 
+@JAVA_TRUE@JAV = java
 @MACOSX_FALSE@INSTALLOSX = 
 @MACOSX_TRUE@INSTALLOSX = install-exec-local-osx
 
diff -Naur work/cyrus-sasl-2.1.21/plugins/aliengssapi.c work/cyrus-sasl-2.1.21b/plugins/aliengssapi.c
--- work/cyrus-sasl-2.1.21/plugins/aliengssapi.c	1970-01-01 01:00:00.000000000 +0100
+++ work/cyrus-sasl-2.1.21b/plugins/aliengssapi.c	2006-07-09 23:41:17.000000000 +0200
@@ -0,0 +1,1010 @@
+/* ALIEN GSSAPI SASL PLUGIN
+ * Artem Harutyunyan (hartem@mail.yerphi.am)
+ * Arsen Hayrapetyan (ahairape@mail.yerphi.am) 
+ * $Id$
+ */
+ 
+/* 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <gssapi.h>
+
+#include <stdio.h>
+#include <string.h> 
+
+#define STRUCT_IOVEC_DEFINED
+#undef HAVE_SOCKLEN_T
+#include <config.h>
+#include <sasl.h>
+#include <saslplug.h>
+
+#include "plugin_common.h"
+
+#ifdef macintosh 
+#include <sasl_aliengssapi_plugin_decl.h> 
+#endif 
+
+/*****************************  Common Section  *****************************/
+
+//static const char plugin_id[] = "$Id$";
+
+/****************************** GSS routines ********************/
+struct server_context;
+struct client_context;
+
+gss_buffer_t create (int, char*);
+gss_buffer_t GSS_buffer_new (char*);
+gss_name_t GSS_name_new(char *);
+gss_buffer_t nameToBuffer(gss_name_t );
+
+static void display_status_1(char*, OM_uint32, int);
+static void display_status(char*, OM_uint32, OM_uint32);
+
+char * getUserCertSubject(gss_name_t targetSubject);
+
+void serverClean (struct server_context **, const sasl_utils_t *utils);
+void clientClean (struct client_context **, const sasl_utils_t *utils);
+
+/*****************************  Server Section  *****************************/
+typedef struct server_context {
+        char * username;
+	unsigned   firstStep;
+	gss_buffer_t inputBuffer;
+	gss_buffer_t outputBuffer;
+	gss_ctx_id_t s_context_hdl;
+	char *out;
+} server_context_t;
+
+static int aliengssapi_server_mech_new( void *glob_context __attribute__((unused)), 
+				 	sasl_server_params_t *sparams,
+					const char *challenge __attribute__((unused)),
+					unsigned challen __attribute__((unused)),
+					void **conn_context)
+{
+	
+	/* holds state are in */
+	if (!conn_context) {
+		PARAMERROR( sparams->utils );
+		return SASL_BADPARAM;
+	}
+	
+	server_context_t *srvCon = (server_context_t *) sparams->utils->malloc(sizeof(server_context_t));
+	memset(srvCon, 0, sizeof(server_context_t));
+	
+	
+	if (srvCon == NULL)
+		return SASL_NOMEM;
+	srvCon->firstStep =1;
+
+	*conn_context = srvCon;		
+
+	return SASL_OK;
+ 
+}
+
+static int aliengssapi_server_mech_step(void *conn_context __attribute__((unused)),
+				  	sasl_server_params_t *params,
+					const char *clientin,
+					unsigned clientinlen,
+					const char **serverout,
+					unsigned *serveroutlen,
+					sasl_out_params_t *oparams)
+{
+	
+	/* Get the username out of clientin*/
+	server_context_t * srvCon = (server_context_t *) conn_context;
+	int usrlen = 0;
+	unsigned int i;
+	char *isRoleOK;
+	int result;
+	unsigned ret = 0;
+	
+	int len;
+	
+	OM_uint32 s_min_stat = 0;
+	OM_uint32 s_maj_stat = GSS_S_CONTINUE_NEEDED;
+	OM_uint32 s_ret_flags;
+	
+	
+	if (srvCon->firstStep == 1)
+	{
+		for (i = 0; (i < clientinlen) && (clientin[i] != '\0'); i++)
+			usrlen++;
+		
+		srvCon->username = params->utils->malloc(usrlen + 1);
+		strncpy (srvCon->username, clientin, usrlen+1);
+		
+		/* init conext handle for GSS */
+		srvCon->s_context_hdl = GSS_C_NO_CONTEXT; 
+	
+		*serverout = "USERROLEOK";
+		*serveroutlen = 10;
+		
+		srvCon->out = NULL;
+		
+		srvCon->firstStep =2;
+		return SASL_CONTINUE;
+	}
+	else if (srvCon->firstStep == 2)
+	{
+	
+		if (srvCon->out) {
+			free(srvCon->out);
+			srvCon->out = NULL;
+		}
+		
+		/*init buffers*/
+		srvCon->outputBuffer = create(0,"");
+		srvCon->inputBuffer = create(clientinlen,clientin);
+		
+		s_min_stat = 0;
+
+		s_maj_stat = gss_accept_sec_context ( &s_min_stat, 
+						      &srvCon->s_context_hdl,
+						      GSS_C_NO_CREDENTIAL,
+						      srvCon->inputBuffer,
+						      GSS_C_NO_CHANNEL_BINDINGS, 
+						      NULL, 
+						      NULL,
+						      srvCon->outputBuffer, 
+						      &s_ret_flags, 
+						      NULL, 
+						      NULL);
+
+		len = srvCon->outputBuffer->length;
+
+		srvCon->out = (char *) params->utils->malloc (len);
+		memcpy (srvCon->out, srvCon->outputBuffer->value,  len); 
+		
+		/* release inputBuffer */						      
+		if( gss_release_buffer(&s_min_stat, srvCon->inputBuffer) !=  GSS_S_COMPLETE )
+			{
+			params->utils->seterror (params->utils->conn,
+				0, "aliengssapi server authentication error: Could not release outputbuffer\n");
+			display_status("Error codes",s_maj_stat,s_min_stat);
+				serverClean(&srvCon, params->utils);
+			return SASL_FAIL;
+			}
+			
+		/* release outputBuffer */
+		if( gss_release_buffer(&s_min_stat, srvCon->outputBuffer)!= GSS_S_COMPLETE)
+			{
+			params->utils->seterror (params->utils->conn,
+				0, "aliengssapi server authentication error: Could not release inputbuffer\n");
+			display_status("Error codes",s_maj_stat,s_min_stat);
+			serverClean(&srvCon, params->utils);
+				return SASL_FAIL;
+			}
+		
+			
+		if (s_maj_stat == GSS_S_CONTINUE_NEEDED){
+			*serverout = srvCon->out; /*(char *) srvCon->outputBuffer->value;*/
+			*serveroutlen = len; /*srvCon->outputBuffer->length;*/
+			return SASL_CONTINUE;
+		}
+		else if (s_maj_stat == GSS_S_COMPLETE){
+			/* GSS verification complete !!! */
+
+			/*release outputbuffer*/
+			if( (s_maj_stat=gss_release_buffer(&s_min_stat, srvCon->outputBuffer))!= GSS_S_COMPLETE)
+			{
+				params->utils->seterror (params->utils->conn,0, "aliengssapi server authentication error: Could not release ouputbuffer\n");
+				display_status("Error codes",s_maj_stat,s_min_stat);
+				ret = 1;	
+			}
+			
+			/*release inputbuffer*/
+			if( (s_maj_stat=gss_release_buffer(&s_min_stat, srvCon->inputBuffer))!= GSS_S_COMPLETE)
+			{
+				params->utils->seterror (params->utils->conn,0, "aliengssapi server authentication error: Could not release inputbuffer\n");
+				display_status("Error codes",s_maj_stat,s_min_stat);
+				ret = 1;	
+			}
+			if (ret) 
+			{
+				serverClean(&srvCon, params->utils);
+				return SASL_FAIL;
+			}
+			/*Check the role*/
+			if ( _plug_get_authid(params->utils, &isRoleOK, NULL) == SASL_OK) 
+			{
+
+
+				if ( strncmp (isRoleOK, "1", 1) == 0) /* Means everything is OK with role */
+				{
+				params->utils->free(isRoleOK);
+				result = params->canon_user(params->utils->conn,
+					srvCon->username, 0, SASL_CU_AUTHID, oparams);
+
+				if (result != SASL_OK) {
+					params->utils->seterror(params->utils->conn, 0,
+						"aliengssapi server authentication error: can not canonicalize userid");
+					serverClean(&srvCon, params->utils);
+					return SASL_FAIL;
+				}
+
+				result = params->canon_user(params->utils->conn,
+					srvCon->username, 0, SASL_CU_AUTHZID, oparams);
+				
+				if (result != SASL_OK) {
+					params->utils->seterror(params->utils->conn, 0,
+						"aliengssapi server authentication error: can not canonicalize authid");
+					serverClean(&srvCon, params->utils);
+					return SASL_FAIL;
+				}
+				
+				
+
+				oparams->doneflag = 1;
+				oparams->mech_ssf = 0;
+				oparams->maxoutbuf = 0;
+				oparams->encode_context = NULL;
+				oparams->encode = NULL;
+				oparams->decode_context = NULL;
+				oparams->decode = NULL;
+				oparams->param_version = 0;
+				
+				*serverout = "GSSAPISASL OK";
+				*serveroutlen = strlen(*serverout);
+				
+				serverClean(&srvCon, params->utils);
+				return SASL_OK;
+				}
+				
+				/**/
+				params->utils->seterror (params->utils->conn,0, "aliengssapi server authentication error:: Could not authenticate as desired role\n");
+				serverClean(&srvCon, params->utils);
+				return SASL_FAIL;
+			}
+			params->utils->seterror (params->utils->conn,0, 
+				"aliengssapi server authentication error: Could not call role checking function\n");
+			serverClean(&srvCon, params->utils);
+			return SASL_FAIL;
+		}
+		else{
+			params->utils->seterror (params->utils->conn,0, 
+				"aliengssapi server authentication error: gss_accept_sec_context failure\n");
+
+			display_status("Error codes",s_maj_stat,s_min_stat);			
+			/*release outputbuffer*/
+			if( (s_maj_stat=gss_release_buffer(&s_min_stat, srvCon->outputBuffer))!= GSS_S_COMPLETE)
+			{
+				params->utils->seterror (params->utils->conn,0, "aliengssapi server authentication error: Could not release outputbuffer\n");
+				display_status("Error codes",s_maj_stat,s_min_stat);
+			}			
+			
+			/*release inputbuffer*/
+			if( (s_maj_stat=gss_release_buffer(&s_min_stat, srvCon->inputBuffer))!= GSS_S_COMPLETE)
+			{
+				params->utils->seterror (params->utils->conn,0, "aliengssapi server authentication error: Could not release inputbuffer\n");
+				display_status("Error codes",s_maj_stat,s_min_stat);
+			}
+
+			
+			serverClean(&srvCon, params->utils);
+			return SASL_FAIL;		
+		}
+		
+		
+	}
+	
+	/*Should never get here*/
+	serverClean(&srvCon, params->utils);
+	return SASL_FAIL;
+}
+
+static void aliengssapi_server_mech_dispose ( void *conn_context __attribute__((unused)),
+				              const sasl_utils_t *utils __attribute__((unused)))
+{
+ 
+}
+
+static sasl_server_plug_t aliengssapi_server_plugins[] = 
+{
+    {
+	"GSSAPI",			  /* mech_name */
+	0,				  /* max_ssf */
+	SASL_SEC_NOANONYMOUS,		  /* security_flags */
+	SASL_FEAT_WANT_CLIENT_FIRST,	  /* features */
+	NULL,				  /* glob_context */
+	&aliengssapi_server_mech_new,	  /* mech_new */
+	&aliengssapi_server_mech_step,	  /* mech_step */
+	&aliengssapi_server_mech_dispose, /* mech_dispose */
+	NULL,				  /* mech_free */
+	NULL,				  /* setpass */
+	NULL,				  /* user_query */
+	NULL,				  /* idle */
+	NULL,				  /* mech_avail */
+	NULL				  /* spare */
+    }
+};
+
+
+int aliengssapi_server_plug_init(const sasl_utils_t *utils,
+			   int maxversion,
+			   int *out_version,
+			   sasl_server_plug_t **pluglist,
+			   int *plugcount)
+{
+    if (maxversion < SASL_SERVER_PLUG_VERSION) {
+	SETERROR(utils, "ALIENGSSAPI version mismatch");
+	return SASL_BADVERS;
+    }
+    
+    *out_version = SASL_SERVER_PLUG_VERSION;
+    *pluglist = aliengssapi_server_plugins;
+    *plugcount = 1;  
+    
+    
+    return SASL_OK;
+}
+
+/*****************************  Client Section  *****************************/
+typedef struct client_context {
+        char *username;
+	char *role;
+	unsigned int step;
+	
+	char *service; // Authen subject ;-)
+	gss_name_t target;
+	gss_buffer_t inputBuffer;
+	gss_buffer_t outputBuffer;
+	gss_ctx_id_t context_hdl;
+} client_context_t;
+
+static int aliengssapi_client_mech_new(void *glob_context __attribute__((unused)),
+				 sasl_client_params_t *params,
+				 void **conn_context)
+{
+	
+	client_context_t *clientContext;
+	
+	    	
+	/* Allocate memory for client context */
+	clientContext = params->utils->malloc(sizeof(client_context_t));
+	if (clientContext == NULL) {
+		MEMERROR( params->utils );
+		return SASL_NOMEM;
+	}
+	
+	memset(clientContext, 0, sizeof(client_context_t));
+	
+	*conn_context = clientContext;
+
+	/* clientContext->service is the Authen subject */
+	clientContext->service = params->utils->malloc(params->servicelen + 1);
+	strncpy (clientContext->service, params->service, params->servicelen + 1);
+
+	/* clientContext->target is the Authen subject (gss_name_t)*/
+	clientContext->target = GSS_name_new (clientContext->service);
+	
+
+	
+	/* Initialize input and output buffers for GSS*/
+
+	clientContext->inputBuffer = create(0,"");
+	clientContext->outputBuffer = create(0,"");
+	
+	/* Initialize context handle for GSS*/
+	clientContext->context_hdl = GSS_C_NO_CONTEXT;
+
+	/*Get clientcert subject*/
+
+	clientContext->username = getUserCertSubject (clientContext->target); 
+
+	if (clientContext->username != NULL){
+		if ( _plug_get_authid(params->utils, &clientContext->role, NULL) == SASL_OK) {
+			
+			clientContext->step = 1;
+
+			return SASL_OK;
+		}
+		else {
+			params->utils->seterror(params->utils->conn, 0,
+				"aliengssapi client authentication error: Can not get role from callback !!!");
+				clientClean(&clientContext, params->utils);
+			return SASL_FAIL;
+			/*No role provided*/
+		}
+	}
+	else {
+			params->utils->seterror(params->utils->conn, 0,
+				"aliengssapi client authentication error: Can not get cert subject from callback !!!");
+			/*Unable to get certificate subject*/
+			clientClean(&clientContext, params->utils);
+			return SASL_FAIL;
+	}
+	clientClean(&clientContext, params->utils);
+	return SASL_FAIL;
+}
+
+static int aliengssapi_client_mech_step(void *conn_context,
+				  sasl_client_params_t *params,
+				  const char *serverin ,
+				  unsigned serverinlen ,
+				  sasl_interact_t **prompt_need __attribute__((unused)),
+				  const char **clientout,
+				  unsigned *clientoutlen,
+				  sasl_out_params_t *oparams)
+{
+
+	
+	int result;
+	client_context_t *clientContext = (client_context_t *) conn_context;
+	unsigned int i,j;
+
+	OM_uint32 min_stat = 0; 
+	OM_uint32 maj_stat = 1; 
+	OM_uint32 ret_flags=0;
+	unsigned ret = 0;
+	
+	/* If it's a first step we have to return "username role" */
+	if (clientContext->step == 1)
+	{
+		
+		*clientoutlen = strlen (clientContext->username) + 
+		1 + 
+		strlen (clientContext->role);
+		
+		
+		char *tmpClientOut = (char *) params->utils->malloc(  *clientoutlen ); 	
+		*clientout = tmpClientOut;
+		
+		
+		i = 0;
+		/* put username into clientout*/
+		for (j = 0; j < strlen(clientContext->username); j++)
+		{
+			/*(*clientout)[i] = clientContext->username[j];*/
+			tmpClientOut[i] = clientContext->username[j];
+			++i;
+		}
+		
+		/* put role into clientout*/
+		/* (*clientout)[i] = '\0'; */
+		tmpClientOut[i] = '\0';
+		++i;
+		
+		for (j = 0; j < strlen(clientContext->role); j++)
+		{
+			/*(*clientout)[i] = clientContext->role[j];*/
+			tmpClientOut[i] = clientContext->role[j];
+			++i;
+		}
+		
+
+		clientContext->step = 2;
+		return SASL_CONTINUE;
+	}
+	else if ( clientContext->step == 2) /*Means we've to send gsi context*/
+	{
+		/*release inputBuffer*/
+		if( (maj_stat=gss_release_buffer(&min_stat, clientContext->inputBuffer))!= GSS_S_COMPLETE)
+		{
+			params->utils->seterror (params->utils->conn,0, "aliengssapi client authentication error: Could not release inputbuffer\n");
+			display_status("Error codes",maj_stat,min_stat);
+		        ret = 1;	
+		}	
+		
+		/*release  outputBuffer*/
+		if( (maj_stat=gss_release_buffer(&min_stat, clientContext->outputBuffer))!= GSS_S_COMPLETE)
+		{
+			params->utils->seterror (params->utils->conn,0, "aliengssapi client authentication error:  Could not release outputbuffer\n");
+			display_status("Error codes",maj_stat,min_stat);
+			ret = 1;	
+		}
+		if (ret) 
+		{
+		clientClean(&clientContext, params->utils);
+		return SASL_FAIL;
+		}
+		
+		/* Check if it is a first step of GSS negotiation
+		   if so create empty input buffer
+		
+		otherwise put data from serverin to inputbuffer */
+		  
+		 if ( strncmp (serverin, "USERROLEOK", 10) == 0 )
+		 {
+				clientContext->inputBuffer  = create(0, ""); 
+		}
+		else 
+		 clientContext->inputBuffer  = create(serverinlen, serverin);
+ 
+		 clientContext->outputBuffer  = create(0,"");
+			
+		min_stat = 0; 
+		maj_stat = 1;	
+		
+		
+		maj_stat = gss_init_sec_context( &min_stat, 
+					 	GSS_C_NO_CREDENTIAL, 
+						&clientContext->context_hdl, 
+						clientContext->target, 
+						GSS_C_NO_OID,
+						GSS_C_MUTUAL_FLAG,
+						0,
+						GSS_C_NO_CHANNEL_BINDINGS, 
+						clientContext->inputBuffer, 
+						NULL, 
+						clientContext->outputBuffer, 
+						&ret_flags, 
+						NULL);
+	
+		
+ 		if (maj_stat == GSS_S_CONTINUE_NEEDED)
+		{
+		
+			*clientout = (char *) clientContext->outputBuffer->value;
+			*clientoutlen = clientContext->outputBuffer->length;
+			return SASL_CONTINUE;
+		}
+		else if (maj_stat == GSS_S_COMPLETE)
+		{
+			*clientout = (char *) clientContext->outputBuffer->value;
+			*clientoutlen = clientContext->outputBuffer->length;
+			clientContext->step =3;
+			return SASL_CONTINUE;
+		}
+		else 
+		{
+			params->utils->seterror (params->utils->conn,
+				0, "aliengssapi client authentication error:  gss_init_sec_context exited abnormally \n");
+			display_status("Error codes",maj_stat,min_stat);		
+			/*release inputBuffer*/
+			if( (maj_stat=gss_release_buffer(&min_stat, clientContext->inputBuffer))!= GSS_S_COMPLETE)
+			{
+			
+			params->utils->seterror (params->utils->conn,0, "aliengssapi client authentication error: Could not release inputbuffer\n");
+			display_status("Error codes",maj_stat,min_stat);
+		        	
+			}	
+		
+			/*release  outputBuffer*/
+			if( (maj_stat=gss_release_buffer(&min_stat, clientContext->outputBuffer))!= GSS_S_COMPLETE)
+			{
+			params->utils->seterror (params->utils->conn,0, "aliengssapi client authentication error: Could not release outputbuffer\n");
+			display_status("Error codes",maj_stat,min_stat);
+			
+			}
+			
+			
+
+			clientClean(&clientContext, params->utils);
+			return SASL_FAIL;		
+		}
+	
+	}
+	else if (clientContext->step == 3) // Check last step !!!
+	{
+	
+		/*release inputBuffer*/
+		if( (maj_stat=gss_release_buffer(&min_stat, clientContext->inputBuffer))!= GSS_S_COMPLETE)
+		{
+			
+			params->utils->seterror (params->utils->conn,0, "aliengssapi client authentication error: Could not release inputbuffer\n");
+			display_status("Error codes",maj_stat,min_stat);
+		        ret = 1;	
+		}	
+		
+		/*release  outputBuffer*/
+		if( (maj_stat=gss_release_buffer(&min_stat, clientContext->outputBuffer))!= GSS_S_COMPLETE)
+		{
+			params->utils->seterror (params->utils->conn,0, "aliengssapi client authentication error: Could not release outputbuffer\n");
+			display_status("Error codes",maj_stat,min_stat);
+			ret = 1;	
+		}
+
+		if (ret) {
+		clientClean(&clientContext, params->utils);
+		return SASL_FAIL;
+		}
+	
+	/*
+	Here we check if it is a last step 
+	if it says "GSSAPISASL_OK" we have to return 
+	SASL_OK
+	*/
+		
+		if ( (serverinlen > 0) && (strncmp (serverin, "GSSAPISASL OK", strlen("GSSAPISASL OK")) == 0))
+		{
+		result = params->canon_user( params->utils->conn,
+			                clientContext->username, 0, SASL_CU_AUTHID, oparams);
+		
+		if (result != SASL_OK) {
+			params->utils->seterror(params->utils->conn, 0,
+				"aliengssapi client authentication error: can not canonicalize userid");
+			clientClean(&clientContext, params->utils);
+			return SASL_FAIL;
+		}
+		
+		  result = params->canon_user( params->utils->conn,
+						clientContext->username, 0, SASL_CU_AUTHZID, oparams);
+		
+		   if (result != SASL_OK) {
+			params->utils->seterror(params->utils->conn, 0,
+				"aliengssapi client authentication error: can not canonicalize authid");
+			clientClean(&clientContext, params->utils);
+			return SASL_FAIL;
+		}
+			oparams->doneflag = 1;
+			oparams->mech_ssf = 0;
+			oparams->maxoutbuf = 0;
+			oparams->encode_context = NULL;
+			oparams->encode = NULL;
+			oparams->decode_context = NULL;
+			oparams->decode = NULL;
+			oparams->param_version = 0;
+		clientClean(&clientContext, params->utils);
+		return SASL_OK;
+		}
+	}
+ /*
+	Should never get here
+  */	
+clientClean(&clientContext, params->utils);
+return SASL_FAIL;
+}
+
+static void aliengssapi_client_mech_dispose ( void *conn_context __attribute__((unused)),
+				              const sasl_utils_t *utils __attribute__((unused)))
+{
+ 
+}
+
+
+static sasl_client_plug_t aliengssapi_client_plugins[] = 
+{
+    {
+	"GSSAPI",			  /* mech_name */
+	0,				  /* max_ssf */
+	SASL_SEC_NOANONYMOUS,		  /* security_flags */
+	SASL_FEAT_WANT_CLIENT_FIRST,	  /* features */
+	NULL,				  /* required_prompts */
+	NULL,				  /* glob_context */
+	&aliengssapi_client_mech_new,	  /* mech_new */
+	&aliengssapi_client_mech_step,	  /* mech_step */
+	&aliengssapi_client_mech_dispose, /* mech_dispose */
+	NULL,				  /* mech_free */
+	NULL,				  /* idle */
+	NULL,				  /* spare */
+	NULL				  /* spare */
+    }
+};
+
+int aliengssapi_client_plug_init(sasl_utils_t *utils,
+			   int maxversion,
+			   int *out_version,
+			   sasl_client_plug_t **pluglist,
+			   int *plugcount)
+{
+    if (maxversion < SASL_CLIENT_PLUG_VERSION) {
+	SETERROR(utils, "ALIEN_GSSAPI version mismatch");
+	return SASL_BADVERS;
+    }
+    
+    *out_version = SASL_CLIENT_PLUG_VERSION;
+    *pluglist = aliengssapi_client_plugins;
+    *plugcount = 1;
+    
+    /*   NEED to fill
+		*/
+    
+    return SASL_OK;
+}
+
+/*****************************************************************************/
+
+/***************************** GSS routines *********************************/
+
+gss_buffer_t create (int len, char *value){
+	void *temp;
+	gss_buffer_t output;
+	
+	temp = malloc(len);
+	output = (gss_buffer_t)malloc(sizeof(gss_buffer_desc));
+	output->length = len;
+	output->value = memcpy(temp, value, len);
+
+	return output;
+}
+
+gss_buffer_t GSS_buffer_new (char *name){
+	
+	gss_buffer_t buffer_t;
+	buffer_t = (gss_buffer_t)malloc(sizeof(gss_buffer_desc));
+	if(strlen(name) != 0) {
+	  buffer_t->length=strlen(name)+1;
+	  buffer_t->value=strdup(name);
+	}
+	else
+	  buffer_t->length = 0;
+	 return buffer_t;
+}
+
+gss_name_t GSS_name_new(char *name){
+
+        OM_uint32 major_status = 0;
+        OM_uint32 minor_status = 0;
+        gss_buffer_desc buffer;
+        
+        gss_name_t gss_name;
+        long len;
+
+        len = strlen(name);
+        if(len == 0) {
+          buffer.length=0;
+        }
+        else {
+          buffer.length=len+1;
+          buffer.value=strdup(name);
+        }
+
+        major_status = gss_import_name(&minor_status,&buffer,GSS_C_NULL_OID,&gss_name);
+
+        if(major_status != GSS_S_COMPLETE) 
+	display_status("Error codes",major_status,minor_status);
+	
+  gss_release_buffer(&minor_status,&buffer);
+
+return  gss_name;
+}
+
+static void display_status_1(char *m, OM_uint32 code, int type) {
+  OM_uint32 maj_stat, min_stat;
+  gss_buffer_desc msg;
+  OM_uint32 msg_ctx;
+  
+  msg_ctx = 0;
+  while (1) {
+    maj_stat = gss_display_status(&min_stat, code,
+				  type, GSS_C_NULL_OID,
+				  &msg_ctx, &msg);
+    printf("GSS-API error %s: %s\n", m,
+	   (char *)msg.value); 
+    (void) gss_release_buffer(&min_stat, &msg);
+    
+    if (!msg_ctx)
+      break;
+  }
+}
+
+void display_status(char *msg, OM_uint32 maj_stat, OM_uint32 min_stat){
+     if (msg) {
+       display_status_1(msg, maj_stat, GSS_C_GSS_CODE);
+       display_status_1(msg, min_stat, GSS_C_MECH_CODE);
+     }
+}
+
+char * getUserCertSubject(gss_name_t target)
+{
+	char *retVal;
+	gss_buffer_t subj;
+	gss_ctx_id_t context_hdl = GSS_C_NO_CONTEXT;
+	
+	OM_uint32 min_stat = 0; 
+	OM_uint32 maj_stat = 1; 
+	OM_uint32 ret_flags=0;
+	
+	OM_uint32 lifetime = 0;
+	gss_OID mech = (gss_OID)malloc(sizeof(gss_OID));
+	
+	OM_uint32 ctx_flags = 0;
+	int locally_initialized = 0;
+	int si_status1 = 0 ;
+	
+	gss_name_t src = GSS_name_new("/c=am");
+
+		
+
+	gss_buffer_t inputBuffer = create(0,"");
+	gss_buffer_t outputBuffer = create(0,"");
+
+	
+	maj_stat = gss_init_sec_context( &min_stat, 
+					 GSS_C_NO_CREDENTIAL, 
+					 &context_hdl, 
+					 target, 
+					 GSS_C_NO_OID,
+					 GSS_C_MUTUAL_FLAG,
+					 0,
+					 GSS_C_NO_CHANNEL_BINDINGS, 
+					 inputBuffer, 
+					 NULL, 
+					 outputBuffer, 
+					 &ret_flags, 
+					 NULL);
+					 
+	
+	if (maj_stat !=  GSS_S_CONTINUE_NEEDED)
+	{
+
+	display_status("Error codes",maj_stat,min_stat);
+	}
+	
+	maj_stat=gss_inquire_context( 	&min_stat, 
+					 context_hdl,
+					 &src,
+					 NULL,
+					 &lifetime,
+					 &mech,
+					 &ctx_flags,
+					 &locally_initialized,
+					 &si_status1);
+					 
+
+	subj = nameToBuffer (src);
+
+	/*release  outputBuffer*/
+	if( (maj_stat=gss_release_buffer(&min_stat, outputBuffer))!= GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+	
+			
+
+	/*release  inputBuffer*/
+	if( (maj_stat=gss_release_buffer(&min_stat, inputBuffer))!= GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+	
+
+	
+	/*release name*/
+	if( (maj_stat=gss_release_name(&min_stat, &src ))!= GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+	
+
+	if (mech) free(mech);
+
+		
+	if (maj_stat == GSS_S_COMPLETE ) 
+	{
+
+		retVal = strdup (subj->value);
+
+		gss_release_buffer(&min_stat, subj);
+
+		return retVal;
+	}
+	
+
+	/*release  subj*/
+	if( (maj_stat=gss_release_buffer(&min_stat, subj))!= GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+
+	return NULL;
+}
+
+
+gss_buffer_t nameToBuffer(gss_name_t name)
+{
+	OM_uint32 major_status = 0;
+	OM_uint32 minor_status = 0;
+	gss_buffer_t ptr;
+	gss_OID name_type;
+	ptr=(gss_buffer_t)malloc(sizeof(gss_buffer_desc));
+	major_status = gss_display_name(&minor_status,name,ptr,&name_type);
+
+return ptr;
+}
+
+/************************ Cleanup routines   *********************************/
+void serverClean (server_context_t **context, const sasl_utils_t *utils)
+{
+	
+/*
+        char * username;
+	unsigned   firstStep;
+	gss_buffer_t inputBuffer;
+	gss_buffer_t outputBuffer;
+	gss_ctx_id_t s_context_hdl;
+	char *out;
+*/
+	OM_uint32 min_stat=0; 
+	OM_uint32 maj_stat=0;
+	
+	if ( *context == NULL ) return;
+
+	
+	if ((*context)->username){ 
+		utils->free((*context)->username);
+		(*context)->username = NULL;
+	}
+
+	/*release GSS security context*/
+	if((maj_stat=gss_delete_sec_context(&min_stat,&((*context)->s_context_hdl) ,GSS_C_NO_BUFFER))!=GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+		
+	if ((*context)->out) {
+			free((*context)->out);
+			(*context)->out = NULL;
+		}		
+		
+	utils->free((*context));
+	*context = NULL;
+	
+}
+
+void clientClean (client_context_t **context, const sasl_utils_t *utils)
+{
+	OM_uint32 maj_stat = 0;
+	OM_uint32 min_stat = 0;
+	
+	if (! (*context)) return;
+	
+/*
+        char *username;
+	char *role;
+	unsigned int step;
+	
+	char *service; // Authen subject ;-)
+	gss_name_t target;
+	gss_buffer_t inputBuffer;
+	gss_buffer_t outputBuffer;
+	gss_ctx_id_t context_hdl;
+*/
+	if ((*context)->username){ 
+		utils->free((*context)->username);
+		(*context)->username = NULL;
+	}
+	
+	if ((*context)->role){ 
+		utils->free((*context)->role);
+		(*context)->username = NULL;
+	}
+	
+	if ((*context)->service){ 
+		utils->free((*context)->service);
+		(*context)->service = NULL;
+	}
+	
+	/*release target*/
+	if( (maj_stat=gss_release_name(&min_stat,  &((*context)->target)))!= GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+
+
+	/*release GSS security context*/
+	if((maj_stat=gss_delete_sec_context(&min_stat,&((*context)->context_hdl) ,GSS_C_NO_BUFFER))!=GSS_S_COMPLETE)
+		display_status("Error codes",maj_stat,min_stat);
+		
+	
+	utils->free((*context));
+	(*context) = NULL;
+}
+
+
diff -Naur work/cyrus-sasl-2.1.21/plugins/alienssh.c work/cyrus-sasl-2.1.21b/plugins/alienssh.c
--- work/cyrus-sasl-2.1.21/plugins/alienssh.c	1970-01-01 01:00:00.000000000 +0100
+++ work/cyrus-sasl-2.1.21b/plugins/alienssh.c	2006-07-09 23:41:06.000000000 +0200
@@ -0,0 +1,836 @@
+/* ALIEN SSH SASL plugin
+ * Artem Harutyunyan (hartem@mail.yerphi.am)
+ * Arsen Hayrapetyan (ahairape@mail.yerphi.am) 
+ * $Id$
+ */
+ 
+/* 
+* Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer. 
+*
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in
+*    the documentation and/or other materials provided with the
+*    distribution.
+*
+* 3. The name "Carnegie Mellon University" must not be used to
+*    endorse or promote products derived from this software without
+*    prior written permission. For permission or any other legal
+*    details, please contact  
+*      Office of Technology Transfer
+*      Carnegie Mellon University
+*      5000 Forbes Avenue
+*      Pittsburgh, PA  15213-3890
+*      (412) 268-4387, fax: (412) 268-7395
+*      tech-transfer@andrew.cmu.edu
+*
+* 4. Redistributions of any form whatsoever must retain the following
+*    acknowledgment:
+*    "This product includes software developed by Computing Services
+*     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+*
+* CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+* THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+* AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+* FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+* WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+* AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*/
+
+
+#include <openssl/rand.h>
+#include <openssl/bio.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <stdio.h>
+
+#include <config.h>
+#include <stdio.h>
+#include <string.h> 
+#include <sasl.h>
+#define MD5_H  /* suppress internal MD5 */
+#include <saslplug.h>
+
+
+
+#include "plugin_common.h"
+
+#ifdef macintosh 
+#include <sasl_alienssh_plugin_decl.h> 
+#endif 
+
+#define RAND_STRING_LEN 128
+
+/*****************************  Common Section  *****************************/
+
+//static const char plugin_id[] = "$Id$";
+
+/****************************** Encrypt/Decrypt routines ********************/
+
+struct server_context;
+struct client_context;
+
+typedef unsigned char UC;
+typedef unsigned long UL;
+typedef struct{
+	RSA* rsa;
+	int padding;
+	int hashMode;
+} rsaData;
+
+/* Prototypes of functions */
+void print_last_error(void);
+void prng_seed(int );
+rsaData* new_private_key(char* , int );
+rsaData* new_public_key(char* , int );
+rsaData* _new_public_key_pkcs1(char* , int ); 
+RSA* _load_rsa_key(char* , int , RSA*(*p_loader)(BIO*, RSA**, pem_password_cb*, void*) );
+rsaData* make_rsa_obj(RSA* );
+
+void serverClean (struct server_context **, const sasl_utils_t *utils);
+void clientClean (struct client_context **, const sasl_utils_t *utils);
+
+/*****************************  Server Section  *****************************/
+
+typedef struct server_context {
+	rsaData     *pub_key_rsa;	
+	UC 	    *rand_bytes;
+	UC           step;
+	char 	    *username;
+	
+	UC    *encBytes;
+	long  encBytesLen;
+	
+} server_context_t;
+
+
+static int alienssh_server_mech_new(void *glob_context __attribute__((unused)), 
+				    sasl_server_params_t *sparams,
+				    const char *challenge __attribute__((unused)),
+				    unsigned challen __attribute__((unused)),
+				    void **conn_context)
+{
+	sasl_secret_t *key = NULL;
+	int res;
+	unsigned int free_key; /* set if we need to free 'key' */ 
+	server_context_t *srvCon;
+
+	/* holds state are in */
+	if (!conn_context) {
+		PARAMERROR( sparams->utils );
+		return SASL_BADPARAM;
+	}
+	
+	/* Allocate memory for server context */
+	
+	srvCon = (server_context_t *) sparams->utils->malloc(sizeof(server_context_t));
+	memset(srvCon, 0, sizeof(server_context_t));
+	
+	if (srvCon == NULL)
+		return SASL_NOMEM;
+	
+	*conn_context = srvCon;
+
+	/* try to get the key */ 
+	res = _plug_get_password(sparams->utils, &key, &free_key, NULL);
+
+	if ((res != SASL_OK) && (res != SASL_INTERACT)) {
+
+		serverClean(&srvCon, sparams->utils);
+		return res;
+	}
+
+	/* "convert" key to rsaData structure and store in srv context */ 
+	srvCon->pub_key_rsa = new_public_key (key->data, key->len);
+
+	if ( ! srvCon->pub_key_rsa ) {
+		sparams->utils->seterror(sparams->utils->conn, 0,
+			"alienssh server authentication error: Can not create RSA* srtucture from callback data !!!");
+			
+		if (free_key) _plug_free_secret (sparams->utils, &key);
+		serverClean(&srvCon, sparams->utils);
+
+		return SASL_FAIL;
+	}
+
+	/* Don't need 'key' anymore
+	    free the memory */
+
+    	if (free_key) _plug_free_secret (sparams->utils, &key);
+	
+	srvCon->rand_bytes = (UC *) sparams->utils->malloc(RAND_STRING_LEN);
+
+	/* Here we have to generate random bytes and store them in server context */ 
+	if ( ! RAND_bytes (srvCon->rand_bytes, RAND_STRING_LEN) )
+	{
+		print_last_error();
+		sparams->utils->seterror(sparams->utils->conn, 0,
+			"alienssh server authentication error: RAND_bytes() failure");
+		serverClean(&srvCon, sparams->utils);
+		return SASL_FAIL;	
+	}
+	
+	srvCon->step = 1;
+
+	return SASL_OK;
+}
+
+static int alienssh_server_mech_step(void *conn_context ,
+				     sasl_server_params_t *params,
+				     const char *clientin,
+				     unsigned clientinlen,
+				     const char **serverout,
+				     unsigned *serveroutlen,
+				     sasl_out_params_t *oparams)
+{
+	server_context_t *srvCon = (server_context_t *) conn_context;
+
+	srvCon->encBytes = (UC* )params->utils->malloc((RSA_size(srvCon->pub_key_rsa->rsa)) * sizeof(UC));
+
+	unsigned int    i;
+	const char  *isRoleOK;
+	int result;
+	
+	if (srvCon->step == 1) /* Encrypt random bytes && return encrypted sequence */ 
+	{
+		int usrlen=0;
+		
+		
+		for (i = 0; (i < clientinlen) && (clientin[i] != '\0'); i++)
+			usrlen++;
+
+		srvCon->username = params->utils->malloc(usrlen + 1);
+
+		strncpy (srvCon->username, clientin, usrlen+1);
+
+
+		srvCon->step = 0;
+		
+		/* PRNG has to be seeded prior to encryption of data */
+
+
+		prng_seed(20);
+
+		srvCon->encBytesLen = RSA_public_encrypt (  RAND_STRING_LEN, 
+							    srvCon->rand_bytes, 
+							    srvCon->encBytes, 
+							    srvCon->pub_key_rsa->rsa, 
+							    srvCon->pub_key_rsa->padding );
+
+
+		if( srvCon->encBytesLen < 0){
+			
+		params->utils->seterror(params->utils->conn, 0,
+			"alienssh server authentication error: RSA_public_encrypt() failure");
+			print_last_error();
+			serverClean(&srvCon, params->utils);
+			return SASL_FAIL;
+		}
+
+		*serverout = srvCon->encBytes;
+		*serveroutlen = srvCon->encBytesLen;
+
+		return SASL_CONTINUE;
+		
+	}
+	
+	else {  /* Check !!!*/
+		
+		
+		if ( clientinlen != RAND_STRING_LEN)
+		{
+			params->utils->seterror(params->utils->conn, 0,
+			"alienssh server authentication error: client data length invalid.");
+			
+			serverClean(&srvCon, params->utils);
+			return SASL_FAIL;
+		}
+		
+		for (i = 0; i < clientinlen; i++)
+			if (srvCon->rand_bytes[i] != (UC) clientin[i] )
+			{
+				params->utils->seterror(params->utils->conn, 0,
+					"alienssh server authentication error: dedcrypted client sequence is incorrect");
+				
+				serverClean(&srvCon, params->utils);
+				return SASL_FAIL;
+			}
+		
+		/*  Decrypted data is OK 
+		now Check the role */ 
+		
+		if ( _plug_get_authid(params->utils, &isRoleOK, NULL) == SASL_OK) 
+		{
+			if ( strncmp (isRoleOK, "1", 1) == 0) /* Means everything is OK with role */
+			{
+				
+				params->utils->free(isRoleOK);
+				
+				result = params->canon_user(params->utils->conn,
+					srvCon->username, 0, SASL_CU_AUTHID, oparams);
+				
+				if (result == SASL_OK)
+				result = params->canon_user(params->utils->conn,
+					srvCon->username, 0, SASL_CU_AUTHZID, oparams);
+				else {
+					params->utils->seterror(params->utils->conn, 0,
+						"alienssh server authentication error: can't canonicalize username.");
+					
+					serverClean(&srvCon, params->utils);
+					return SASL_FAIL;
+				}
+				
+				if (result != SASL_OK) {
+						params->utils->seterror(params->utils->conn, 0,
+						"alienssh server authentication error: can't canonicalize authid");
+					
+					serverClean(&srvCon, params->utils);
+					return SASL_FAIL;
+				}
+				
+				oparams->doneflag = 1;
+				oparams->mech_ssf = 0;
+				oparams->maxoutbuf = 0;
+				oparams->encode_context = NULL;
+				oparams->encode = NULL;
+				oparams->decode_context = NULL;
+				oparams->decode = NULL;
+				oparams->param_version = 0;
+				
+				
+				*serverout = "SSHSASL OK";
+				*serveroutlen = strlen(*serverout);
+				
+				serverClean(&srvCon, params->utils);
+				return SASL_OK;
+			}
+			params->utils->seterror(params->utils->conn, 0,
+			"alienssh server authentication error: role verification failure");
+			
+			serverClean(&srvCon, params->utils);
+			return SASL_FAIL;
+		}
+		params->utils->seterror(params->utils->conn, 0,
+			"alienssh server authentication error: can't call role verification callback");
+		
+			serverClean(&srvCon, params->utils);
+			return SASL_FAIL;
+	}
+	
+	serverClean(&srvCon, params->utils);
+	return SASL_FAIL;
+	/*
+  	SHOULD NEVER GET HERE
+	*/
+}
+
+static void alienssh_server_mech_dispose( void *conn_context __attribute__((unused)),
+				          const sasl_utils_t *utils __attribute__((unused)))
+{
+ 
+}
+
+static sasl_server_plug_t alienssh_server_plugins[] = 
+{
+	{
+		"SSH",				/* mech_name */
+		0,				/* max_ssf */
+		SASL_SEC_NOANONYMOUS,		/* security_flags */
+		SASL_FEAT_WANT_CLIENT_FIRST,	/* features */
+		NULL,				/* glob_context */
+		&alienssh_server_mech_new,	/* mech_new */
+		&alienssh_server_mech_step,	/* mech_step */
+		&alienssh_server_mech_dispose,	/* mech_dispose */
+		NULL,				/* mech_free */
+		NULL,				/* setpass */
+		NULL,				/* user_query */
+		NULL,				/* idle */
+		NULL,				/* mech_avail */
+		NULL				/* spare */
+	}
+};
+
+
+int alienssh_server_plug_init(const sasl_utils_t *utils,
+			      int maxversion,
+			      int *out_version,
+			      sasl_server_plug_t **pluglist,
+			      int *plugcount)
+{
+	if (maxversion < SASL_SERVER_PLUG_VERSION) {
+		SETERROR(utils, "ALIEN_SSH version mismatch");
+		return SASL_BADVERS;
+	}
+	
+	*out_version = SASL_SERVER_PLUG_VERSION;
+	*pluglist = alienssh_server_plugins;
+	*plugcount = 1;  
+	
+
+	
+	return SASL_OK;
+}
+
+/*****************************  Client Section  *****************************/
+typedef struct client_context {
+	rsaData     *priv_key_rsa;
+	UC	     step;
+	char 	    *username;
+	char 	    *role;
+	
+	char *tmp;
+} client_context_t;
+
+static int alienssh_client_mech_new(void *glob_context __attribute__((unused)),
+				    sasl_client_params_t *params,
+				    void **conn_context)
+{
+	client_context_t *clientContext;
+	int result;
+	sasl_secret_t *key = NULL;
+	unsigned int free_key; /* set if we need to free 'key' */
+    	
+	/* Allocate memory for client context */
+	clientContext = params->utils->malloc(sizeof(client_context_t));
+	if (clientContext == NULL) {
+		MEMERROR( params->utils );
+		return SASL_NOMEM;
+	}
+	
+	memset(clientContext, 0, sizeof(client_context_t));
+	
+	*conn_context = clientContext;
+	
+	/* try to get the username and role  */
+	if ( _plug_get_userid(params->utils, &clientContext->username, NULL) == SASL_OK) { 
+		if ( _plug_get_authid(params->utils, &clientContext->role, NULL) == SASL_OK) {
+			
+			/* try to get the key */
+			result = _plug_get_password(params->utils, &key, &free_key, NULL);
+			if ((result != SASL_OK) && (result != SASL_INTERACT)) {
+				
+				clientClean(&clientContext, params->utils);
+				return result;
+			}
+			
+			/* "convert" key to rsaData structure and store in client context */
+			clientContext->priv_key_rsa = new_private_key (key->data, key->len);
+			if ( ! clientContext->priv_key_rsa) {
+				params->utils->seterror(params->utils->conn, 0,
+					"alienssh client authentication error: Can not create RSA* structure from callback data !!!");
+				
+				clientClean(&clientContext, params->utils);
+				print_last_error();
+				return SASL_FAIL;
+			
+			}
+			clientContext->tmp = NULL;
+			clientContext->step = 1;
+			return SASL_OK;
+		}
+		else {
+			clientClean(&clientContext, params->utils);
+			params->utils->seterror(params->utils->conn, 0,
+					"alienssh client authentication error: Can not get role from callback !!!");
+				return SASL_FAIL;
+			/*No role provided*/
+		}
+	}
+	else {
+		clientClean(&clientContext, params->utils);	
+		params->utils->seterror(params->utils->conn, 0,
+					"alienssh client authentication error: Can not get username from callback !!!");
+				return SASL_FAIL;
+			/*No username provided*/
+	}
+}
+
+static int alienssh_client_mech_step(void *conn_context,
+				     sasl_client_params_t *params,
+				     const char *serverin ,
+				     unsigned serverinlen ,
+				     sasl_interact_t **prompt_need __attribute__((unused)),
+				     const char **clientout,
+				     unsigned *clientoutlen,
+				     sasl_out_params_t *oparams)
+{
+	int result;
+	client_context_t *clientContext = (client_context_t *) conn_context;
+	unsigned int i,j;
+	/*char *tmpClientOut = (char *) (*clientout);*/
+
+	/*
+	Check whether this is a first step
+	If it is, then we have to return "username role" 
+	*/
+	
+	if (clientContext->step == 1)
+	{
+		*clientoutlen = strlen (clientContext->username)     + 
+		1 + 
+		strlen (clientContext->role) 
+		;
+		
+		if (clientContext->tmp) params->utils->free(clientContext->tmp);
+		
+		clientContext->tmp = (char *) params->utils->malloc(*clientoutlen); 
+		*clientout = clientContext->tmp;			
+		i = 0;
+		/* put username into clientout */
+		for (j = 0; j < strlen(clientContext->username); j++)
+		{
+
+		/*(*clientout)[i] = clientContext->username[j];*/
+		/*tmpClientOut[i] = clientContext->username[j];*/
+		clientContext->tmp[i] = clientContext->username[j];
+			++i;
+		}
+		
+		/* put role into clientout */
+
+		/* (*clientout)[i] = '\0';*/
+		/* tmpClientOut[i] = '\0';*/
+		clientContext->tmp[i] = '\0';
+		++i;
+		
+		for (j = 0; j < strlen(clientContext->role); j++)
+		{
+			/*(*clientout)[i] = clientContext->role[j];*/
+			/*tmpClientOut[i] = clientContext->role[j];*/
+			clientContext->tmp[i] = clientContext->role[j];
+			++i;
+		}
+		
+		clientContext->step = 2;
+		return SASL_CONTINUE;
+		
+	}
+	else if  (clientContext->step == 2)
+	{
+		/*
+		Second step !
+		Here we have to decode and return what we find in serverin
+		using key from client context
+		*/
+		clientContext->step = 3;
+		
+		if (clientContext->tmp) params->utils->free(clientContext->tmp);
+		
+		clientContext->tmp = (UC *) params->utils->malloc((RSA_size(clientContext->priv_key_rsa->rsa))* sizeof(UC)); 
+		*clientout = clientContext->tmp;
+		
+		result = RSA_private_decrypt ( serverinlen, 
+			serverin, 
+			*clientout, 
+			clientContext->priv_key_rsa->rsa, 
+			clientContext->priv_key_rsa->padding );
+		
+		if( result < 0){
+			/* Report error here */
+			params->utils->seterror(params->utils->conn, 0,
+				"alienssh client authentication error: RSA_private_decrypt() failure !!!");
+			print_last_error();
+			clientClean(&clientContext, params->utils);
+			return SASL_FAIL;
+		}	
+		else {
+			*clientoutlen = result;
+			return SASL_CONTINUE;
+		}
+		
+	}
+	else  if (clientContext->step == 3)
+	{
+		if ( (serverinlen > 0) && (strncmp (serverin, "SSHSASL OK", strlen("SSHSASL OK")) == 0))
+			{	/* Last step*/				                                 
+				
+			result = params->canon_user(params->utils->conn,
+				clientContext->username, 0, SASL_CU_AUTHID, oparams);
+			
+			if (result != SASL_OK) {
+				params->utils->seterror(params->utils->conn, 0,
+					"alienssh client authentication error: can not canonicalize userid");
+				
+				clientClean(&clientContext, params->utils);
+				return SASL_FAIL;
+			}
+			result = params->canon_user(params->utils->conn,
+				clientContext->role, 0, SASL_CU_AUTHZID, oparams);
+			
+			if (result != SASL_OK) {
+				params->utils->seterror(params->utils->conn, 0,
+					"alienssh client authentication error: can not canonicalize authid");
+				
+				clientClean(&clientContext, params->utils);
+				return SASL_FAIL;
+			}
+			
+			oparams->doneflag = 1;
+			oparams->mech_ssf = 0;
+			oparams->maxoutbuf = 0;
+			oparams->encode_context = NULL;
+			oparams->encode = NULL;
+			oparams->decode_context = NULL;
+			oparams->decode = NULL;
+			oparams->param_version = 0;
+			
+			
+			clientClean(&clientContext, params->utils);
+			
+			return SASL_OK;
+			}
+			
+		params->utils->seterror(params->utils->conn, 0,
+			"alienssh client authentication error: server didn't say SSHSASL OK ");
+		return SASL_FAIL;
+	}
+	
+	
+	
+	return SASL_FAIL;
+	/*
+  	SHOULD NEVER GET HERE
+	*/
+}
+
+static void alienssh_client_mech_dispose( void *conn_context __attribute__((unused)),
+				          const sasl_utils_t *utils __attribute__((unused)))
+{
+ 
+}
+
+
+static sasl_client_plug_t alienssh_client_plugins[] = 
+{
+	{
+		"SSH",				/* mech_name */
+		0,				/* max_ssf */
+		SASL_SEC_NOANONYMOUS,		/* security_flags */
+		SASL_FEAT_WANT_CLIENT_FIRST,	/* features */
+		NULL,				/* required_prompts */
+		NULL,				/* glob_context */
+		&alienssh_client_mech_new,		/* mech_new */
+		&alienssh_client_mech_step,	/* mech_step */
+		&alienssh_client_mech_dispose,	/* mech_dispose */
+		NULL,				/* mech_free */
+		NULL,				/* idle */
+		NULL,				/* spare */
+		NULL				/* spare */
+	}
+};
+
+int alienssh_client_plug_init( sasl_utils_t *utils,
+			       int maxversion,
+			       int *out_version,
+			       sasl_client_plug_t **pluglist,
+			       int *plugcount)
+{
+	if (maxversion < SASL_CLIENT_PLUG_VERSION) {
+		SETERROR(utils, "ALIEN_SSH version mismatch");
+		return SASL_BADVERS;
+	}
+	
+	*out_version = SASL_CLIENT_PLUG_VERSION;
+	*pluglist = alienssh_client_plugins;
+	*plugcount = 1;
+	
+	/*   NEED to fill
+	*/
+
+	
+	return SASL_OK;
+}
+
+/*****************************************************************************/
+void print_last_error(void){
+	UL e;
+	const char * lib = NULL;
+	const char * func = NULL;
+	const char * reason = NULL;
+	
+
+	ERR_load_crypto_strings();
+
+	e = ERR_peek_error();
+
+	lib = ERR_lib_error_string(e);
+
+	func = ERR_func_error_string(e);
+
+	reason = ERR_reason_error_string(e);
+
+	
+	printf("%d: %s: %s: %s\n", e, lib, func, reason);
+
+	ERR_clear_error();
+
+			
+}
+
+
+void prng_seed(int num){
+	UC * rand_bytes;
+	
+	rand_bytes = (UC* )malloc(num * sizeof(UC));
+	if(! rand_bytes){
+		printf("Unable to allocate memory\n");
+		return;
+	}
+	
+		if(!RAND_bytes(rand_bytes, num))
+			print_last_error();
+		else RAND_seed(rand_bytes, num);
+		free(rand_bytes);
+}
+
+
+rsaData* new_private_key(char *keyString, int keyStringLen){
+	
+	return   make_rsa_obj(_load_rsa_key(keyString,keyStringLen, PEM_read_bio_RSAPrivateKey));
+}
+
+
+rsaData* new_public_key(char *keyString, int keyStringLen){
+	
+	char *pkcs1str = "-----BEGIN RSA PUBLIC KEY-----";
+	
+	int pkcs1len = strlen(pkcs1str);
+	char tmp_pkcs1[pkcs1len+1];
+	
+	strncpy(tmp_pkcs1, keyString, pkcs1len);
+	tmp_pkcs1[pkcs1len]='\0';
+	
+	if(strcmp(tmp_pkcs1, pkcs1str)==0)
+	{
+		return _new_public_key_pkcs1(keyString, keyStringLen);
+	}
+	else 
+		return NULL;
+	
+}
+
+
+rsaData* _new_public_key_pkcs1(char *keyString, int keyStringLen){
+	return make_rsa_obj(_load_rsa_key(keyString, keyStringLen, PEM_read_bio_RSAPublicKey));
+}
+
+
+RSA* _load_rsa_key(char* keyString, int keyStringLen, RSA*(*p_loader)(BIO*, RSA**, pem_password_cb*, void*)){
+	BIO *stringBIO = NULL;
+	RSA *rsa = NULL;
+
+
+	if(!(stringBIO = BIO_new_mem_buf(keyString,keyStringLen))){
+		print_last_error();	
+		return NULL;
+	}
+	
+
+	rsa = p_loader(stringBIO, NULL, 0, NULL);
+
+	BIO_set_close(stringBIO, BIO_CLOSE);
+
+	BIO_free(stringBIO);	
+
+	
+	if(!rsa){
+
+		print_last_error();
+		return NULL;
+	}
+
+	return rsa;
+}
+
+
+rsaData* make_rsa_obj(RSA* rsa){
+	rsaData * retVal = NULL;
+	
+	if(!(retVal = (rsaData *)malloc(sizeof(rsaData))) ){
+		printf("%s\n", "Unable to allocate memory");
+		return NULL;
+	}
+	
+	retVal->rsa = rsa;
+	retVal->hashMode = NID_sha1;
+	retVal->padding = RSA_PKCS1_OAEP_PADDING;
+	
+	return retVal;
+}
+
+/************************ Cleanup routines   *********************************/
+void serverClean (server_context_t **context, const sasl_utils_t *utils)
+{
+
+	if ( *context == NULL ) return;
+
+	if ((*context)->rand_bytes){
+
+		utils->free((*context)->rand_bytes);
+		(*context)->rand_bytes = NULL;
+	}
+	
+	if ((*context)->username) {
+		utils->free((*context)->username);
+		(*context)->username = NULL;
+	}
+	
+	if ((*context)->encBytes) {
+		utils->free((*context)->encBytes);
+		(*context)->encBytes = NULL;
+	}
+	
+	if ((*context)->pub_key_rsa){
+		/* free pub_key_rsa */;
+		
+		RSA_free(((*context)->pub_key_rsa)->rsa);
+		free(((*context)->pub_key_rsa));
+
+		(*context)->pub_key_rsa = NULL;
+	}
+	
+	utils->free((*context));
+	*context = NULL;
+	
+}
+
+void clientClean (client_context_t **context, const sasl_utils_t *utils)
+{
+
+	if (! (*context)) return;
+	
+
+	if ((*context)->username){ 
+		utils->free((*context)->username);
+		(*context)->username = NULL;
+	}
+	
+	if ((*context)->role){
+		utils->free((*context)->role);
+		(*context)->role = NULL;
+	}
+	
+	if ((*context)->tmp){
+		utils->free((*context)->tmp);
+		(*context)->tmp = NULL;
+	}
+	
+	
+	if ((*context)->priv_key_rsa) {
+
+		RSA_free(((*context)->priv_key_rsa)->rsa);
+		free(((*context)->priv_key_rsa));
+
+		(*context)->priv_key_rsa = NULL;
+	}
+	
+	utils->free((*context));
+	(*context) = NULL;
+}
diff -Naur work/cyrus-sasl-2.1.21/plugins/alientoken.c work/cyrus-sasl-2.1.21b/plugins/alientoken.c
--- work/cyrus-sasl-2.1.21/plugins/alientoken.c	1970-01-01 01:00:00.000000000 +0100
+++ work/cyrus-sasl-2.1.21b/plugins/alientoken.c	2006-07-09 23:41:12.000000000 +0200
@@ -0,0 +1,467 @@
+/* ALIEN TOKEN SASL plugin
+ * Artem Harutyunyan (hartem@mail.yerphi.am)
+ * Arsen Hayrapetyan (ahairape@mail.yerphi.am) 
+ * $Id$
+ */
+ 
+/* 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <string.h> 
+#include <sasl.h>
+
+#include <saslplug.h>
+
+
+#include "plugin_common.h"
+
+#ifdef macintosh 
+#include <sasl_alientoken_plugin_decl.h> 
+#endif 
+
+
+
+/*****************************  Common Section  *****************************/
+
+//static const char plugin_id[] = "$Id$";
+
+/*****************************  Server Section  *****************************/
+
+
+static int alientoken_server_mech_new(void *glob_context __attribute__((unused)), 
+				 sasl_server_params_t *sparams,
+				 const char *challenge __attribute__((unused)),
+				 unsigned challen __attribute__((unused)),
+				 void **conn_context)
+{
+	
+	/* holds state are in */
+	if (!conn_context) {
+		PARAMERROR( sparams->utils );
+		return SASL_BADPARAM;
+	}
+	
+	*conn_context = NULL;
+		
+	return SASL_OK;
+ 
+}
+
+static int alientoken_server_mech_step(void *conn_context __attribute__((unused)),
+				       sasl_server_params_t *params,
+				       const char *clientin __attribute__((unused)),
+				       unsigned clientinlen __attribute__((unused)),
+				       const char **serverout,
+				       unsigned *serveroutlen,
+				       sasl_out_params_t *oparams)
+{
+	const char  *isRoleOK;
+	
+	int usrlen = 0;
+	int result;
+	unsigned int i;
+	
+	
+	/* Get the username out from clientin*/
+	for (i = 0; (i < clientinlen) && (clientin[i] != '\0'); i++)
+		usrlen++;
+	
+	char username[usrlen + 1];
+	
+	strncpy (username, clientin, usrlen+1);
+	
+	
+	if ( _plug_get_authid(params->utils, &isRoleOK, NULL) == SASL_OK) 
+  	{
+		if ( strncmp (isRoleOK, "1", 1) == 0) 
+			/* Callback function made verification */
+			{
+				
+				params->utils->free(isRoleOK);
+				
+				result = params->canon_user(params->utils->conn,
+					username, 0, SASL_CU_AUTHID, oparams);
+				
+				if (result != SASL_OK) {
+					params->utils->seterror(params->utils->conn, 0,
+						"alientoken server authentication error: can not canonicalize userid");
+					
+					return SASL_FAIL;
+				}
+				
+				result = params->canon_user(params->utils->conn,
+					username, 0, SASL_CU_AUTHZID, oparams);
+				
+				if (result != SASL_OK) {
+					params->utils->seterror(params->utils->conn, 0,
+						"alientoken server authentication error: can not canonicalize authid");
+					
+					return SASL_FAIL;
+				}
+				
+				oparams->doneflag = 1;
+				oparams->mech_ssf = 0;
+				oparams->maxoutbuf = 0;
+				oparams->encode_context = NULL;
+				oparams->encode = NULL;
+				oparams->decode_context = NULL;
+				oparams->decode = NULL;
+				oparams->param_version = 0;
+				
+				*serverout = "TOKENSASL OK";
+				*serveroutlen = strlen(*serverout);
+				
+				return SASL_OK;
+			}
+			else 
+			{
+			params->utils->seterror(params->utils->conn, 0,
+				"alientoken server authentication error: role verification failure");
+			return SASL_FAIL;
+			}
+	}
+	params->utils->seterror(params->utils->conn, 0,
+		"alientoken server authentication error: can't call role verification callback");
+	
+return SASL_FAIL;
+}
+
+static void alientoken_server_mech_dispose ( void *conn_context __attribute__((unused)),
+				             const sasl_utils_t *utils __attribute__((unused)))
+{
+ 
+}
+
+static sasl_server_plug_t alientoken_server_plugins[] = 
+{
+    {
+	"TOKEN",			  /* mech_name */
+	0,				  /* max_ssf */
+	SASL_SEC_NOANONYMOUS,		  /* security_flags */
+	SASL_FEAT_WANT_CLIENT_FIRST,	  /* features */
+	NULL,				  /* glob_context */
+	&alientoken_server_mech_new,	  /* mech_new */
+	&alientoken_server_mech_step,	  /* mech_step */
+	&alientoken_server_mech_dispose,  /* mech_dispose */
+	NULL,				  /* mech_free */
+	NULL,				  /* setpass */
+	NULL,				  /* user_query */
+	NULL,				  /* idle */
+	NULL,				  /* mech_avail */
+	NULL				  /* spare */
+    }
+};
+
+
+int alientoken_server_plug_init(const sasl_utils_t *utils,
+			   int maxversion,
+			   int *out_version,
+			   sasl_server_plug_t **pluglist,
+			   int *plugcount)
+{
+    if (maxversion < SASL_SERVER_PLUG_VERSION) {
+	SETERROR(utils, "ALIENTOKEN version mismatch");
+	return SASL_BADVERS;
+    }
+    
+    *out_version = SASL_SERVER_PLUG_VERSION;
+    *pluglist = alientoken_server_plugins;
+    *plugcount = 1;  
+    
+    
+    return SASL_OK;
+}
+
+/*****************************  Client Section  *****************************/
+typedef struct client_context {
+        char *username;
+	char *role;
+	sasl_secret_t *key;
+	unsigned int free_key; /* set if we need to free 'key' */
+	unsigned int firstStep;
+	char *tmp;
+} client_context_t;
+
+static int alientoken_client_mech_new(void *glob_context __attribute__((unused)),
+				 sasl_client_params_t *params,
+				 void **conn_context)
+{
+	
+	client_context_t *clientContext;
+	int result;
+	    	
+	/* Allocate memory for client context */
+	clientContext = params->utils->malloc(sizeof(client_context_t));
+	if (clientContext == NULL) {
+		MEMERROR( params->utils );
+		return SASL_NOMEM;
+	}
+	
+	memset(clientContext, 0, sizeof(client_context_t));
+	
+	*conn_context = clientContext;
+	
+	if ( _plug_get_userid(params->utils, &clientContext->username, NULL) == SASL_OK) { 
+		if ( _plug_get_authid(params->utils, &clientContext->role, NULL) == SASL_OK) {
+			
+			/* try to get the key */
+			result = _plug_get_password(params->utils, &clientContext->key, &clientContext->free_key, NULL);
+			if ((result != SASL_OK) && (result != SASL_INTERACT)) {
+				/* report about missing token 
+				run alien updateToken */
+				
+			params->utils->seterror(params->utils->conn, 0,
+			"alientoken client authentication error: can not get the token. Try to run 'alien updateToken'");
+				return result;
+			}
+			
+			clientContext->firstStep = 1;
+			return SASL_OK;
+		}
+		else {
+			
+			params->utils->seterror(params->utils->conn, 0,
+					"alientoken client authentication error: Can not get role from callback !!!");
+				return SASL_FAIL;
+			
+			/*No role provided*/
+		}
+	}
+	else {
+		params->utils->seterror(params->utils->conn, 0,
+					"alientoken client authentication error: Can not get username from callback !!!");
+				return SASL_FAIL;
+		
+		/*No username provided*/
+	}
+	
+	
+	return SASL_OK;
+	
+}
+
+static int alientoken_client_mech_step(void *conn_context,
+				  sasl_client_params_t *params,
+				  const char *serverin ,
+				  unsigned serverinlen ,
+				  sasl_interact_t **prompt_need __attribute__((unused)),
+				  const char **clientout,
+				  unsigned *clientoutlen,
+				  sasl_out_params_t *oparams)
+{
+
+	
+	int result;
+	client_context_t *clientContext = (client_context_t *) conn_context;
+	unsigned int i,j;
+	
+	/* If it's a first step we have to return "username role token" */
+	if (clientContext->firstStep == 1)
+	{
+		
+		*clientoutlen = strlen (clientContext->username) + 
+				1 + 
+				strlen (clientContext->role) +
+				1 +
+				clientContext->key->len;
+		
+		clientContext->tmp = (char *) params->utils->malloc(  *clientoutlen ); 
+		*clientout = clientContext->tmp; 
+		
+		i = 0;
+		/* put username into clientout*/
+		for (j = 0; j < strlen(clientContext->username); j++)
+		{
+			/*(*clientout)[i] = clientContext->username[j];*/
+			clientContext->tmp[i] = clientContext->username[j];
+			++i;
+		}
+		
+		/* put role into clientout*/
+		/*(*clientout)[i] = '\0';*/
+		clientContext->tmp[i] = '\0';
+		++i;
+		
+		for (j = 0; j < strlen(clientContext->role); j++)
+		{
+			/*(*clientout)[i] = clientContext->role[j];*/
+			clientContext->tmp[i] =	clientContext->role[j];		
+			++i;
+		}
+		
+		/* put token into clientout*/
+		/*(*clientout)[i] = '\0';*/
+		clientContext->tmp[i] = '\0';
+		++i;
+		
+		for ( j = 0; j < clientContext->key->len; j++)
+		{
+			/*(*clientout)[i] = clientContext->key->data[j];*/
+			clientContext->tmp[i] =	clientContext->key->data[j];		
+			++i;
+		}
+		
+		
+		clientContext->firstStep = 0;
+		return SASL_CONTINUE;
+	}
+
+	/*
+		Here we have to check if it is a last step 
+		if it says "TOKENSASL_OK" we have to return 
+		SASL_OK
+	*/
+	
+	if ( (serverinlen > 0) && (strncmp (serverin, "TOKENSASL OK", strlen("TOKENSASL OK")) == 0))
+	{
+		result = params->canon_user( params->utils->conn,
+			clientContext->username, 0, SASL_CU_AUTHID, oparams);
+		
+		if (result != SASL_OK) {
+			params->utils->seterror(params->utils->conn, 0,
+				"alientoken client authentication error: can not canonicalize userid");
+			
+			return SASL_FAIL;
+		}
+		
+		result = params->canon_user( params->utils->conn,
+			clientContext->role, 0, SASL_CU_AUTHZID, oparams);
+		
+		if (result != SASL_OK) {
+			params->utils->seterror(params->utils->conn, 0,
+				"alientoken client authentication error: can not canonicalize authid");
+			
+			return SASL_FAIL;
+		}
+		
+		oparams->doneflag = 1;
+		oparams->mech_ssf = 0;
+		oparams->maxoutbuf = 0;
+		oparams->encode_context = NULL;
+		oparams->encode = NULL;
+		oparams->decode_context = NULL;
+		oparams->decode = NULL;
+		oparams->param_version = 0;
+		
+		return SASL_OK;
+	}
+	params->utils->seterror(params->utils->conn, 0,
+			"alientoken client authentication error: server didn't say TOKENSASL OK ");
+		return SASL_FAIL;
+
+}
+
+static void alientoken_client_mech_dispose( void *conn_context,
+				            const sasl_utils_t *utils)
+{
+client_context_t *clientContext = (client_context_t *) conn_context;
+    
+    if (!clientContext) return;
+    
+    if (clientContext->username)
+    {
+	    utils->free( clientContext->username );
+	    clientContext->username=NULL;
+    }
+	    
+    if (clientContext->role)
+    {
+	    utils->free( clientContext->role );
+	    clientContext->role=NULL;
+    }
+    
+    if (clientContext->tmp)
+    {
+	    utils->free( clientContext->tmp );
+	    clientContext->tmp=NULL;
+    }
+    
+    if (clientContext->free_key) 
+    {
+	    _plug_free_secret(utils, clientContext->key);
+	    clientContext->key = NULL;
+	    clientContext->free_key = 0;
+    }
+    
+     utils->free(clientContext);
+		
+}
+
+static sasl_client_plug_t alientoken_client_plugins[] = 
+{
+    {
+	"TOKEN",			/* mech_name */
+	0,				/* max_ssf */
+	SASL_SEC_NOANONYMOUS,		/* security_flags */
+	SASL_FEAT_WANT_CLIENT_FIRST,	/* features */
+	NULL,				/* required_prompts */
+	NULL,				/* glob_context */
+	&alientoken_client_mech_new,	/* mech_new */
+	&alientoken_client_mech_step,	/* mech_step */
+	&alientoken_client_mech_dispose,/* mech_dispose */
+	NULL,				/* mech_free */
+	NULL,				/* idle */
+	NULL,				/* spare */
+	NULL				/* spare */
+    }
+};
+
+int alientoken_client_plug_init(sasl_utils_t *utils,
+			   int maxversion,
+			   int *out_version,
+			   sasl_client_plug_t **pluglist,
+			   int *plugcount)
+{
+    if (maxversion < SASL_CLIENT_PLUG_VERSION) {
+	SETERROR(utils, "ALIEN_TOKEN version mismatch");
+	return SASL_BADVERS;
+    }
+    
+    *out_version = SASL_CLIENT_PLUG_VERSION;
+    *pluglist = alientoken_client_plugins;
+    *plugcount = 1;
+    
+    
+    return SASL_OK;
+}
+
+/*****************************************************************************/
diff -Naur work/cyrus-sasl-2.1.21/plugins/Makefile.am work/cyrus-sasl-2.1.21b/plugins/Makefile.am
--- work/cyrus-sasl-2.1.21/plugins/Makefile.am	2005-05-07 06:54:18.000000000 +0200
+++ work/cyrus-sasl-2.1.21b/plugins/Makefile.am	2006-07-09 23:21:45.000000000 +0200
@@ -60,6 +60,9 @@
 sql_version = 2:21:0
 ldapdb_version = 2:21:0
 srp_version = 2:21:0
+alienssh_version = 2:21:0
+alientoken_version = 2:21:0
+aliengssapi_version = 2:21:0
 
 INCLUDES=-I$(top_srcdir)/include -I$(top_srcdir)/lib -I$(top_srcdir)/sasldb -I$(top_builddir)/include
 AM_LDFLAGS = -module -export-dynamic -rpath $(plugindir)
@@ -79,7 +82,8 @@
 sasl_LTLIBRARIES = @SASL_MECHS@
 EXTRA_LTLIBRARIES = libplain.la libanonymous.la libkerberos4.la libcrammd5.la \
 	libgssapiv2.la libdigestmd5.la liblogin.la libsrp.la libotp.la \
-	libntlm.la libpassdss.la libsasldb.la libsql.la libldapdb.la
+	libntlm.la libpassdss.la libsasldb.la libsql.la libldapdb.la  \
+	libalienssh.la libalientoken.la libaliengssapi.la
 
 libplain_la_SOURCES = plain.c plain_init.c $(common_sources)
 libplain_la_LDFLAGS = -version-info $(plain_version)
@@ -106,6 +110,22 @@
 libcrammd5_la_DEPENDENCIES = $(COMPAT_OBJS)
 libcrammd5_la_LIBADD = $(COMPAT_OBJS)
 
+libalienssh_la_SOURCES = alienssh.c alienssh_init.c $(common_sources)
+libalienssh_la_LDFLAGS = -version-info $(alienssh_version)
+libalienssh_la_DEPENDENCIES = $(COMPAT_OBJS)
+libalienssh_la_LIBADD = $(ALIENSSH_LIBS) $(COMPAT_OBJS)
+
+libalientoken_la_SOURCES = alientoken.c alientoken_init.c $(common_sources)
+libalientoken_la_LDFLAGS = -version-info $(alientoken_version)
+libalientoken_la_DEPENDENCIES = $(COMPAT_OBJS)
+libalientoken_la_LIBADD = $(COMPAT_OBJS)
+
+libaliengssapi_la_SOURCES = aliengssapi.c aliengssapi_init.c $(common_sources)
+libaliengssapi_la_LDFLAGS = -version-info $(aliengssapi_version)
+libaliengssapi_la_DEPENDENCIES = $(COMPAT_OBJS)
+libaliengssapi_la_LIBADD = $(ALIENGSSAPI_LIBS) $(COMPAT_OBJS)
+
+
 libdigestmd5_la_SOURCES = digestmd5.c digestmd5_init.c $(common_sources)
 libdigestmd5_la_LDFLAGS = -version-info $(digestmd5_version)
 libdigestmd5_la_DEPENDENCIES = $(COMPAT_OBJS)
diff -Naur work/cyrus-sasl-2.1.21/plugins/makeinit.sh work/cyrus-sasl-2.1.21b/plugins/makeinit.sh
--- work/cyrus-sasl-2.1.21/plugins/makeinit.sh	2005-02-16 21:49:49.000000000 +0100
+++ work/cyrus-sasl-2.1.21b/plugins/makeinit.sh	2006-07-09 23:22:39.000000000 +0200
@@ -1,4 +1,4 @@
-for mech in anonymous crammd5 digestmd5 gssapiv2 kerberos4 login ntlm otp passdss plain srp; do
+for mech in anonymous crammd5 digestmd5 gssapiv2 kerberos4 login ntlm otp passdss plain srp alienssh alientoken aliengssapi; do
 
 echo "
 #include <config.h>
